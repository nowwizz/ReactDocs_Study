# Ref로 DOM 조작하기

리액트는 렌더링 결과물에 맞춰 DOM 변경을 자동으로 처리하기 때문에 컴포넌트에서 자주 DOM을 조작해야 할 필요는 없다.

하지만 가끔 특정 노드에 포커스를 옮기거나, 스크롤 위치를 옮기거나, 위치와 크기를 측정하기 위해서 리액트가 관리하는 DOM 요소에 접근해야 할 때가 있다.

리액트는 이런 작업을 수행하는 내장 방법을 제공하지 않기 때문에 DOM 노드에 접근하기 위한 ref가 필요하다.   


## Ref로 노드 가져오기

먼저 리액트가 관리하는 DOM 노드에 접근하기 위해 `useRef`  Hook을 가져온다.

```jsx
import { useRef } from 'react';
```

컴포넌트 안에서 ref를 선언하기 위해 방금 가져온 Hook을 사용한다.

```jsx
const myRef = useRef(null);
```

마지막으로 ref를 DOM 노드를 가져와야 하는 JSX tag에 `ref` 어트리뷰트로 전달한다.

```jsx
<div ref={myRef}>
```

`useRef` Hook은 `current` 라는 단일 속성을 가진 객체를 반환한다.

초기에는 `myRef.current` 가 `null` 이 된다.

리액트가 이 `<div>` 에 대한 DOM 노드를 생성할 때, 리액트는 이 노드에 대한 참조를 `myRef.current` 에 넣는다. 그리고 이 DOM 노드를 이벤트 핸들러에서 접근하거나 노드에 정의된 내장 브라우저 API를 사용할 수 있다.

```jsx
// 예를 들어 이렇게 브라우저 API를 사용할 수 있습니다
myRef.current.scrollIntoView();
```

   
### 예시: 텍스트 입력에 포커스 이동하기

이 예시에서 버튼을 클릭하면 input 요소로 포커스를 이동한다.

```jsx
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}

```

위 예시를 구현하기 위해서

1. `useRef` Hook을 사용하여 `inputRef` 를 선언한다.
2. 선언한 `inputRef` 를 `<input ref={inputRef}>` 처럼 전달한다. 이 행위는 **리액트에 이 `<input>` 의 DOM 노드를 `inputRef.current` 에 넣어줘**라고 하는 것이다.
3. `handleClick` 함수에서 `inputRef.currnet` 에서 input DOM 노드를 읽고 `inputRef.current.focus()` 로 `focus()` 를 호출한다.
4. `<button>` 의 `onClick` 으로 `handleClick` 이벤트 핸들러를 전달한다.

DOM 조작이 ref를 사용하는 가장 일반적인 사용처지만 `useRef` Hook은 setTimeout Timer ID 같은 리액트 외부 요소를 저장하는 용도로도 사용할 수 있다.

state와 비슷하게 ref는 렌더링 사이에도 유지된다. 

ref를 설정하더라도 컴포넌트의 렌더링을 다시 유발하지 않는 state와 유사하다.

### 예시: 한 요소로 스크롤을 이동하기

한 컴포넌트에서 하나 이상의 ref를 가질 수 있다.

이 예시에서는 이미지 3개가 있는 캐러셀이 있다. 각 버튼은 브라우저 `scrollIntoView()` 메서드를 해당 DOM 노드로 호출하여 이미지를 중앙에 배치한다.

```jsx
import { useRef } from 'react';

export default function CatFriends() {
  const firstCatRef = useRef(null);
  const secondCatRef = useRef(null);
  const thirdCatRef = useRef(null);

  function handleScrollToFirstCat() {
    firstCatRef.current.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  function handleScrollToSecondCat() {
    secondCatRef.current.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  function handleScrollToThirdCat() {
    thirdCatRef.current.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  return (
    <>
      <nav>
        <button onClick={handleScrollToFirstCat}>
          Neo
        </button>
        <button onClick={handleScrollToSecondCat}>
          Millie
        </button>
        <button onClick={handleScrollToThirdCat}>
          Bella
        </button>
      </nav>
      <div>
        <ul>
          <li>
            <img
              src="https://placecats.com/neo/300/200"
              alt="Neo"
              ref={firstCatRef}
            />
          </li>
          <li>
            <img
              src="https://placecats.com/millie/200/200"
              alt="Millie"
              ref={secondCatRef}
            />
          </li>
          <li>
            <img
              src="https://placecats.com/bella/199/200"
              alt="Bella"
              ref={thirdCatRef}
            />
          </li>
        </ul>
      </div>
    </>
  );
}

```

   
### ref 콜백을 사용하여 ref 리스트 관리하기

위 예시에서는 미리 정해진 숫자만큼 ref가 있었다.

하지만 때때로 목록의 아이템마다 ref가 필요할 수도 있고 , 얼마나 ref가 필요할지 예측할 수 없는 경우도 있다.

그럴 때 아래 코드는 작동하지 않는다.

```jsx
<ul>
  {items.map((item) => {
    // 작동하지 않습니다!
    const ref = useRef(null);
    return <li ref={ref} />;
  })}
</ul>
```

**왜냐하면 Hook은 컴포넌트의 최상단에서만 호출되어야 하기 때문이다.**

`useRef` 를 반복문, 조건문, 혹은 `map()` 안쪽에서 호출할 수 없다.

이 문제를 해결하는 방법은 부모 요소에서 단일 ref를 얻고, `querySelectorAll` 과 같은 DOM 조작 메서드를 사용하여 그 안에서 개별 자식 노드를 “찾는” 것이다.

하지만 이는 다루기 힘들며 DOM 구조가 바뀌는 경우 작동하지 않을 수 있다.

또 다른 해결책은 **`ref` 어트리뷰트에 함수를 전달하는 것**이다. 이것을 `ref` 콜백이라고 한다.

리액트는 ref를 설정할 때 DOM 노드와 함께 ref 콜백을 호출하며, ref를 지울 때는 null을 전달한다.

이를 통해 자체 배열이나 Map을 유지하고, 인덱스나 특정 ID를 사용하여 어떤 ref에든 접근할 수 있다.

아래 예시는 긴 목록에서 특정 노드에 스크롤하기 위해 앞에서 말한 접근법을 사용한다.

```jsx
import { useRef, useState } from "react";

export default function CatFriends() {
  const itemsRef = useRef(null);
  const [catList, setCatList] = useState(setupCatList);

  function scrollToCat(cat) {
    const map = getMap();
    const node = map.get(cat);
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function getMap() {
    if (!itemsRef.current) {
      // 처음 사용하는 경우, Map을 초기화합니다.
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }

  return (
    <>
      <nav>
        <button onClick={() => scrollToCat(catList[0])}>Neo</button>
        <button onClick={() => scrollToCat(catList[5])}>Millie</button>
        <button onClick={() => scrollToCat(catList[9])}>Bella</button>
      </nav>
      <div>
        <ul>
          {catList.map((cat) => (
            <li
              key={cat}
              ref={(node) => {
                const map = getMap();
                map.set(cat, node);

                return () => {
                  map.delete(cat);
                };
              }}
            >
              <img src={cat} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

function setupCatList() {
  const catList = [];
  for (let i = 0; i < 10; i++) {
    catList.push("https://loremflickr.com/320/240/cat?lock=" + i);
  }

  return catList;
}

```

이 예시에서 `itemsRef` 는 하나의 DOM 노드를 가지고 있지 않는다. 대신에 식별자와 DOM 노드로 연결된 Map을 가지고 있다. (Ref는 어떤 값이든 가질 수 있다)

모든 리스트 아이템에 있는 `ref` 콜백은 Map 변경을 처리한다.

```jsx
<li
  key={cat.id}
  ref={node => {
    const map = getMap();
    // Add to the Map
    map.set(cat, node);

    return () => {
      // Remove from the Map
      map.delete(cat);
    };
  }}
>
```

이렇게 하면 나중에 Map에서 개별 DOM 노드를 읽을 수 있다.

> **중요!**
Strict Mode가 활성화되어 있다면 개발 모드에서 ref 콜백이 두 번 실행된다.
>
> 

## 다른 컴포넌트의 DOM 노드 접근하기

`<input />`  같은 브라우저 요소를 출력하는 내장 컴포넌트에 ref를 주입할 때 리액트는 ref의 `current` 프로퍼티를 그에 해당하는 (브라우저의 실제 `<input />` 같은) DOM 노드로 설정한다.

하지만 `<MyInput />` 같이 직접 만든 컴포넌트에 ref를 주입할 때는 `null` 이 기본적으로 주어진다.

여기 앞서 말한 내용을 설명하는 예시가 있다. 버튼을 클릭할 때 input 요소에 포커스되지 않는 것을 주목해라.

> **주의!**
Ref는 일종의 탈출구이다.
다른 컴포넌트의 DOM 노드를 수동으로 조작하면 코드를 불안정하게 만들 수 있다.
> 

부모 컴포넌트에서 자식 컴포넌트로 ref를 prop 처럼 전달할 수 있다.

```jsx
import { useRef } from 'react';

function MyInput({ ref }) {
  return <input ref={ref} />;
}

function MyForm() {
  const inputRef = useRef(null);
  return <MyInput ref={inputRef} />
}
```

위 예시에서, 부모 컴포넌트인 `MyForm` 에서 ref를 생성하고, 이를 자식 컴포넌트인 `MyInput` 으로 전달한다.

그리고 `MyInput` 은 그 ref를 `<input>` 에 넘겨준다.

`<input>` 은 내장 컴포넌트이므로, 리액트는 해당 ref의 `current`  속성을 `<input>` 요소로 설정한다.

`MyForm` 에서 생성된 `inputRef` 는 이제 `MyInput` 이 반환한 `<input>` DOM 요소를 가리킨다.

그리고 `MyForm` 에서 생성한 클릭 핸들러는 `inputRef` 에 접근하여 `focus()` 를 호출함으로써 `<input>` 에 포커스를 설정할 수 있다.

```jsx
import { useRef } from 'react';

function MyInput({ ref }) {
  return <input ref={ref} />;
}

export default function MyForm() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}

```

   
### 명령형 처리방식으로 하위 API 노출하기

위 예시에서 `MyInput` 에 전달된 ref는 DOM 입력 요소로 전달된다. 그리고 부모 컴포넌트에서 DOM 노드의 `focus()` 를 호출할 수 있게 되었다.

하지만 이에 따라 부모 컴포넌트에서 DOM 노드의 CSS 스타일을 직접 변경하는 등의 예상치 못한 작업을 할 수 있다.

몇몇 상황에서는 노출된 기능을 제한하고 싶을 수 있는데, 이 때 `useImperativeHandle` 을 사용한다.

```jsx
// 필요한 훅들을 import 합니다.
import { useRef, useImperativeHandle, forwardRef } from "react";

// 🧠 자식 컴포넌트: MyInput
// forwardRef를 사용해 부모로부터 전달된 ref를 받을 수 있도록 설정합니다.
const MyInput = forwardRef((props, ref) => {
  // 내부에서 실제 <input> DOM 노드를 가리킬 ref를 만듭니다.
  const realInputRef = useRef(null);

  // 부모에게 전달할 ref 객체를 직접 구성합니다.
  // 여기서 focus 함수만 노출되도록 제한합니다.
  useImperativeHandle(ref, () => ({
    focus() {
      realInputRef.current.focus(); // 내부 input DOM을 직접 조작
    },
  }));

  // input에 내부 ref를 연결합니다.
  return <input ref={realInputRef} />;
});

export default function Form() {
  // 부모 컴포넌트에서 사용할 ref
  // 실제 input DOM이 아닌, 자식이 가공해서 넘겨준 객체를 참조합니다.
  const inputRef = useRef(null);

  function handleClick() {
    // 자식 컴포넌트에서 useImperativeHandle로 정의한 focus()만 접근 가능합니다.
    inputRef.current.focus();
  }

  return (
    <>
      {/* 부모에서 만든 ref를 자식에게 전달 */}
      <MyInput ref={inputRef} />

      {/* 버튼 클릭 시 자식 컴포넌트의 focus 기능 실행 */}
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}

```

여기 `MyInput` 내부의 `realInputRef` 는 실제 input DOM 노드를 가지고 있다.

하지만 `useImperativeHandle` 을 사용하여 리액트가 ref를 참조하는 부모 컴포넌트에 직접 구성한 객체를 전달하도록 지시한다.

따라서 `Form`  컴포넌트 안쪽의 `inputRef.current` 는 `focus` 메서드만 가지고 있다. 이 경우 ref는 DOM 노드가 아니라 `useInperativeHandle`  호출에서 직접 구성한 객체가 된다.

이걸 정확히 왜 쓰냐!
자식 컴포넌트 입장에서는 부모가 너무 많은 DOM 조작 권한을 가지고 있는게 불안할 수 있음

그래서 자식 컴포넌트에서 ref에 어떤 기능을 쓸지 특정해 조작해서 부모에게 보내는 것

**고급스럽게 말하자면 리액트의 컴포넌트 캡슐화 원칙을 지키기 위해서!**

## 리액트가 ref를 부여할 때

리액트의 모든 갱신은 두 단계로 나눌 수 있다.

- 렌더링 단계에서 리액트는 화면에 무엇을 그려야 하는지 알아내도록 컴포넌트를 호출한다.
- 커밋 단계에서 리액트는 변경사항을 DOM에 적용한다.

일반적으로 렌더링하는 중 ref에 접근하는 것을 원하지 않는다. DOM 노드를 보유하는 ref도 마찬가지이다.

첫 렌더링에서 DOM 노드는 아직 생성되지 않아서 `ref.current` 는 `null` 인 상태이다.

그리고 갱신에 의한 렌더링에서 DOM 노드는 아직 업데이트되지 않은 상태이다.

두 상황 모두 ref를 읽기에 너무 이른 상황이 된다.

리액트는 `ref.current` 를 커밋 단계에서 설정한다. DOM을 변경하기 전에 리액트는 관련된 `ref.current` 값을 미리 `null` 로 설정한다.

그리고 DOM을 변경한 후 리액트는 즉시 대응하는 DOM 노드로 다시 설정한다.

**대부분 `ref` 접근은 이벤트 핸들러 안에서 일어난다.**

ref를 사용하여 뭔가를 하고 싶지만, 그것을 시행할 특정 이벤트가 없을 때 Effect가 필요할 수도 있다.

### flushSync로 state 변경을 동적으로 플러시하기

새로운 할 일을 추가하고 할 일 목록의 마지막으로 화면 스크롤을 내리는 아래 코드를 보자.

어떤 이유에 의해 마지막으로 추가된 할 일의 직전으로 항상 스크롤되는 것을 관찰해라.

```jsx
import { useState, useRef } from 'react';

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState('');
  const [todos, setTodos] = useState(
    initialTodos
  );

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    setText('');
    setTodos([ ...todos, newTodo]);
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>
        Add
      </button>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: 'Todo #' + (i + 1)
  });
}

```

문제는 다음 두 줄에 있다.

```jsx
setTodos([ ...todos, newTodo]);
listRef.current.lastChild.scrollIntoView();
```

리액트에서 state 갱신은 큐에 쌓여 비동기적으로 처리된다.

이렇게 동작하는 것은 일반적으로 기대하는 방향이다. 하지만 여기에선 `setTodos` 가 DOM을 바로 업데이트하지 않기 때문에 문제가 발생한다.

그래서 할 일 목록의 마지막 노드로 스크롤할 때, DOM에 아직 새로운 할 일이 추가되지 않은 상태이다. 위 예시에서 스크롤이 계속 한 항목에 뒤처지는 이유이다.

이 문제를 고치기 위해 리액트가 DOM 변경을 동기적으로 수행하도록 할 수 있다.

이를 위해 `react-dom` 패키지의 `flushSync` 를 가져오고 state 업데이트를 `flushSync` 호출로 감싸면 된다.

```jsx
flushSync(() => {
  setTodos([ ...todos, newTodo]);
});
listRef.current.lastChild.scrollIntoView();
```

위의 내용은 `flushSync` 로 감싼 코드가 실행된 직후 리액트가 동기적으로 DOM을 변경하도록 지시한다.

결과적으로 마지막 할 일은 스크롤 하기 전에 항상 DOM에 추가되어 있을 것이다.

## ref로 DOM을 조작하는 모범 사례

Ref는 탈출구이다. “리액트에서 벗어나야 할 때”만 사용한다.

포커스 혹은 스크롤 위치를 관리하거나, 리액트가 노출하지 않는 브라우저 API를 호출하는 등의 작업이 이에 포함된다.

포커스 및 스크롤 관리 같은 비 파괴적인 행동을 고수한다면 어떤 문제도 마주치지 않을 것이다.

하지만 DOM을 직접 수정하는 시도를 한다면 리액트가 만들어 내는 변경 사항과 충돌을 발생시킬 위험을 감수해야 한다.

이 문제를 이해하기 위해 이번 예시는 환영 문구와 두 버튼을 포함하고 있다.

첫 버튼은 일반적인 리액트 조건부 렌더링과 state를 사용하여 노드 존재 여부를 토글한다.

두 번째 버튼은 DOM API의 `remove()` 를 사용하여 리액트의 제어 밖에서 노드를 강제적으로 삭제한다.

“Toggle with setState”를 몇 차례 눌러봐라. 메세지가 반복적으로 나타나거나 사라질 것이다.

이후 “Remove from the DOM”을 눌러봐라. 이것은 강제로 노드를 삭제한다.

마지막으로 “Toggle with setState”를 다시 눌러봐라.

```jsx
import {useState, useRef} from 'react';

export default function Counter() {
  const [show, setShow] = useState(true);
  const ref = useRef(null);

  return (
    <div>
      <button
        onClick={() => {
          setShow(!show);
        }}>
        Toggle with setState
      </button>
      <button
        onClick={() => {
          ref.current.remove();
        }}>
        Remove from the DOM
      </button>
      {show && <p ref={ref}>Hello world</p>}
    </div>
  );
}

```

DOM 요소를 직접 삭제한 뒤 `setState` 를 사용하여 다시 DOM 노드를 노출하는 것은 충돌을 발생시킨다.

DOM을 직접 변경했을 때 리액트는 DOM 노드를 올바르게 계속 관리하는 방법을 모르기 때문이다.

**리액트가 관리하는 DOM 노드를 직접 바꾸려 하지 마라.**

리액트가 관리하는 DOM 요소에 대한 수정, 자식 추가 혹은 자식 삭제는 비일관적인 시각적 결과 혹은 위 예시처럼 충돌로 이어진다.

하지만 항상 이것을 할 수 없다는 의미는 아니다. 주의 깊게 사용해야 한다.

**안전하게 리액트가 업데이트할 이유가 없는 DOM 노드 일부를 수정할 수 있다.**

예를 들어 몇몇 `<div>` 가 항상 빈 채로 JSX에 있다면, 리액트는 해당 노드의 자식 요소를 건드릴 이유가 없다.

따라서 빈 노드에서 엘리먼트를 추가하거나 삭제하는 것은 안전하다.
