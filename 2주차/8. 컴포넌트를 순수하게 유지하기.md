# 컴포넌트를 순수하게 유지하기

- 일부 자바스크립트 함수는 순수하다.
    - 순수 함수는 오직 연산만을 수행한다,
- 컴포넌트를 엄격하게 순수함수로 작성하면 코드베이스가 점점 커지더라도 예상밖의 동작이나 당황케하는 버그를 피할 수 있다.

## 순수성: 공식으로서의 컴포넌트

- 컴퓨터 과학에서(특히 함수형 프로그래밍의 세계에서는) 순수 함수는 다음과 같은 특징을 지니고 있는 함수이다.
    - **자신의 일에 집중한다.** 함수가 호출되기 전에 존재했던 어떤 객체나 변수는 변경하지 않는다.
    - **같은 입력, 같은 출력.** 같은 입력이 주어졌다면 순수함수는 같은 결과를 반환한다.
        
        ```tsx
        function double(number) {
          return 2 * number;
        }
        ```
        
- 리액트는 이러한 개념을 기반으로 설계되었다.
    - **리액트는 작성되는 모든 컴포넌트가 순수 함수일 거라 가정한다.**
    - 이러한 가정은 작성되는 리액트 컴포넌트에 같은 입력이 주어진다면 반드시 같은 JSX를 반환한다는 것을 의미한다.

## 사이드 이펙트: 의도하지(않은) 결과

- 리액트의 렌더링 과정은 항상 순수해야 한다.
    - 컴포넌트는 JSX만 반환해야 하며, 렌더링 이전에 존재했던 객체나 변수를 변경해서는 안된다.
    
    ```tsx
    let guest = 0;
    
    function Cup() {
      // 나쁜 지점: 이미 존재했던 변수를 변경하고 있습니다!
      guest = guest + 1;
      return <h2>Tea cup for guest #{guest}</h2>;
    }
    
    export default function TeaSet() {
      return (
        <>
          <Cup />
          <Cup />
          <Cup />
        </>
      );
    }
    
    ```
    
    - 이 컴포넌트는 컴포넌트 바깥에 선언된 변수를 읽고 수정하고 있다.
    - 이건 컴포넌트를 여러번 호출하면 다른 JSX를 생성한다는 것을 의미한다. → 예측 불가능 → 혼란스러운 버그
    - 대신 `guest` 변수를 프로퍼티로 넘겨 이 컴포넌트를 고칠 수 있다.
    
    ```tsx
    function Cup({ guest }) {
      return <h2>Tea cup for guest #{guest}</h2>;
    }
    
    export default function TeaSet() {
      return (
        <>
          <Cup guest={1} />
          <Cup guest={2} />
          <Cup guest={3} />
        </>
      );
    }
    
    ```
    
    - 이제 JSX가 반환하는 것은 오직 guest 프로퍼티에만 의존하기 때문에 컴포넌트는 순수하다.
- 일반적으로 컴포넌트가 특정 순서로 렌더링할 것으로 기대하면 안된다
- 각 컴포넌트는 렌더링 중에 다른 컴포넌트와 같이 서로 의존하지 말고 “스스로 생각”해야 한다.

### 엄격 모드로 순수하지 않은 연산을 감지

- 리액트에는 렌더링하면서 읽을 수 있는 세 가지 종류의 입력 요소가 있다.
    - Props
    - State
    - Context
    - 이러한 입력 요소는 항상 읽기 전용으로 취급해야 한다.
- 사용자의 입력에 따라 무언가를 변경하려는 경우,
    - 변수를 직접 수정하는 대신 State를 설정해야 한다.
    - 컴포넌트가 렌더링되는 동안에는 기존 변수나 객체를 변경하면 안된다.
- 리액트는 개발 중에 컴포넌트의 함수를 두 번 호출하는 “엄격 모드”를 제공한다.
    - **컴포넌트 함수를 두 번 호출함으로써, 엄격 모드는 이러한 규칙을 위반하는 컴포넌트를 찾는데 도움을 준다.**
    - 엄격 모드는 프로더거션에 영향을 주지 않기 때문에 사용자의 앱 속도가 느려지지 않는다.
        - 엄격 모드를 사용하기 위해서, 최상단 컴포넌트를 <React.StrictMode>로 감쌀 수 있다.
            - 몇몇 프레임워크는 기본적으로 이 문법을 사용한다.

## 지역 변경: 컴포넌트의 작은 비밀

- 위 예시에서의 문제는 렌더링하는 동안 컴포넌트가 기존 변수를 변경했다는 것이다.
    - 이것은 변경으로 불리워서 조금 무섭게 들린다.
    - 순수 함수는 함수 스코프 밖의 변수나 호출 전에 생성된 객체를 변경하지 않는다.
- 그러나, 렌더링하는 동안 그냥 만든 변수와 객체를 변경하는 것은 전혀 문제가 없다.
    
    ```tsx
    function Cup({ guest }) {
      return <h2>Tea cup for guest #{guest}</h2>;
    }
    
    export default function TeaGathering() {
      let cups = [];
      for (let i = 1; i <= 12; i++) {
        cups.push(<Cup key={i} guest={i} />);
      }
      return cups;
    }
    ```
    
    - 만약 변수나 배열이 함수 바깥에서 생성되었다면 큰 문제가 되었을 것이다.
    - 하지만 이 방식은 괜찮다.
        - 왜냐하면 함수 내부에서 같은 렌더링 동안 생성했기 때문이다.
        - 함수 외부의 어떤 코드도 이 현상이 발생했다는 사실을 알 수 없다.
    - 이를 `지역 변경` 이라고 한다.

## 사이드 이펙트를 일으킬 수 있는 지점

- 함수형 프로그래밍은 순수성에 크게 의존하지만, 언젠가는, 어디에서, 무언가가 바뀌어야 한다.
- 화면을 업데이트하고, 애니메이션을 시작하고, 데이터를 변경하는 이러한 변화를 `사이드 이펙트`라고 한다.
    - 렌더링 중에 발생하는 것이 아니라 “사이드에서” 발생하는 현상

- 리액트에서, 사이드 이펙트는 보통 **이벤트 핸들러**에 포함된다.
    - 이벤트 핸들러는 리액트가 일부 작업을 수행할 때 반응하는 기능이다.
- 이벤트 핸들러가 컴포넌트 내부에 정의되었다고 하더라도 렌더링 중에는 실행되지 않는다.
    - 그래서 이벤트 핸들러는 순수할 필요가 없다.

- 다른 옵션을 모두 사용했지만 사이드 이펙트에 적합한 이벤트 핸들러를 찾을수 없는 경우에도,
    - 컴포넌트에서 `useEffect` 호출을 사용하여 반환된 JSX에 해당 이벤트 핸들러를 연결할 수 있다.
    - 이것은 리액트에게 사이드 이펙트가 허용될 때 렌더링 후 나중에 실행하도록 지시한다.
    - **그러나 이 접근 방식이 마지막 수단이 되어야 한다.**
- 가능하면 렌더링만으로 로직을 표현해 보는게 좋다.

### 리액트는 왜 순수함을 신경쓸까요?

1. 컴포넌트는 다른 환경에서도 실행될 수 있다.
    1. 예를 들면 서버에서?
    2. 동일한 입력에 대해 동일한 결과를 반환하기 때문에 하나의 컴포넌트는 많은 사용자 요청을 처리할 수 있다.
2. 입력이 변경되지 않은 **컴포넌트 렌더링을 건너뛰어** 성능을 향상시킬 수 있다.
    1. 순수 함수는 항상 동일한 결과를 반환하므로 캐시하기에 안전하다.
3. 깊은 컴포넌트 트리를 렌더링하는 도중에 일부 데이터가 변경되는 경우 리액트는 오래된 렌더링을 완료하는 데 시간을 낭비하지 않고 렌더링을 다시 시작할 수 있다.
    1. 순수함은 언제든지 연산을 중단하는 것을 안전하게 한다.
