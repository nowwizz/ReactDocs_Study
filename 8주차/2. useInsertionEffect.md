# useInsertionEffect

> **주의!**
`useInsertionEffect` 는 CSS-in-JS 라이브러리 작성자를 위한 것이다. CSS-in-JS 라이브러리 작업 중에 스타일을 주입할 위치가 필요한 것이 아니라면, `useEffect`  또는 `useLayoutEffect` 를 사용해라.
> 

`useInsertionEffect` 는 **layout Effects**가 실행되기 전에 전체 요소를 **DOM**에 주입할 수 있다.

```jsx
useInsertionEffect(setup, dependencies?)
```

---

## 레퍼런스

### `useInsertionEffect(setup, dependencies?)`

`useInsertionEffect` 를 호출하여 layout을 읽어야 하는 Effects가 호출되기 전에 스타일을 주입할 수 있다.

```jsx
import { useInsertionEffect } from 'react';

// CSS-in-JS 라이브러리 안에서
function useCSS(rule) {
  useInsertionEffect(() => {
    // ... <style> 태그를 여기에서 주입하세요 ...
  });
  return rule;
}
```

### 매개변수

- `setup` : Effect의 로직이 포함된 함수이다. setup 함수는 선택적으로 cleanup 함수를 반환할 수도 있다. 컴포넌트가 DOM에 추가되기 전에 리액트는 setup 함수를 실행한다. `dependencies` 가 변경되어 다시 렌더링될 때마다, 리액트는 (cleanup 함수를 제공했다면) 먼저 이전 값으로 cleanup 함수를 실행한 다음, 새로운 값으로 setup 함수를 실행한다. 컴포넌트가 DOM에서 제거되기 전에 리액트는 cleanup 함수를 한 번 더 실행한다.
- **선택사항** `dependencies` : `setup` 코드 내에서 참조된 모든 반응형 값의 목록이다. 반응형 값에는 props, state, 그리고 컴포넌트 본문에 직접 선언된 모든 변수와 함수가 포함된다. linter가 리액트용으로 설정된 경우, 모든 반응형 값이 의존성으로 올바르게 지정되었는지 확인한다. 의존성 목록에는 일정한 수의 항목이 있어야 하며 `[dep1, dep2, dep3]` 와 같이 작성해야 한다. 리액트는 `Object.is` 비교 알고리즘을 사용하여 의존성을 이전 값과 비교한다. 의존성을 지정하지 않으면 컴포넌트를 다시 렌더링할 때마다 Effect가 다시 실행된다.

### 반환값

`useInsertionEffect` 는 `undefined` 를 반환한다.

### 주의 사항

- 이펙트는 클라이언트에서만 실행된다. 서버 렌더링 중에는 실행되지 않는다.
- `useInsertionEffect` 내부에서는 상태를 업데이트할 수 없다.
- `useInsertionEffect` 가 실행되는 시점에 ref는 아직 연결되지 않는다.
- `useInsertionEffect` 는 DOM의 업데이트 전 또는 후에 실행된다. DOM이 업데이트 되는 특정 시점에 의존해서는 안된다.
- 매번 모든 cleanup을 실행하고 setup하는 다른 Effects와 달리, `useInsertionEffect` 는 하나의 컴포넌트에 대해 cleanup과 setup을 모두 실행한다. 그 결과 cleanup과 setup이 ‘**interleaving**’된다.

> **Interleaving이란?**
다른 Effects들은 모든 cleanup이 실행된 후에 setup을 수행하는데, `useInsertionEffect` 는 cleanup과 setup이 쌍으로, 연속적으로 실행되는데 이것을 Interleaving이라고 한다.
왜냐하면 이 Hook은 스타일을 삽입할 때 사용되는데 쌍으로 실행되지 않으면 삽입 순서가 꼬일 수 있다.
> 

---

## 사용법

### CSS-in-JS 라이브러리에서 동적 스타일 주입하기

전통적으로 plain CSS를 사용해 리액트 컴포넌트의 스타일을 지정했다.

```jsx
// JS 파일 안에서
<button className="success" />

// CSS 파일 안에서
.success { color: green; }
```

일부 팀은 CSS 파일을 작성하는 대신 자바스크립트 코드에서 직접 스타일을 작성하는 것을 선호한다. 이 경우 일반적으로 CSS-in-JS 라이브러리 또는 도구를 사용해야 한다. CSS-in-JS에는 세 가지 일반적인 접근 방식이 있다:

1. 컴파일러를 사용하여 CSS 파일로 정적 추출
2. 인라인 스타일, 예: `<div style={{ opacity: 1 }}>` 
3. 런타임에 `<style>` 태그 주입

CSS-in-JS를 사용하는 경우 처음 두 가지 접근 방식을 조합하여 사용하는 것이 좋다. **런타임 `<style>` 태그 주입은 다음 두 가지 이유로 권장하지 않는다.**

1. 런타임 주입은 브라우저에서 스타일을 훨씬 더 자주 다시 계산하도록 한다.
2. 런타임 주입이 리액트 생명주기 중에 잘못된 시점에 발생하면 속도가 매우 느려질 수 있다.

첫 번째 문제는 해결할 수 없지만 `useInsertionEffect` 를 사용하면 두 번째 문제를 해결할 수 있다.

`useInsertionEffect` 를 호출하여 layout Effects가 발생하기 전에 스타일을 주입한다:

```jsx
// CSS-in-JS 라이브러리 안에서
let isInserted = new Set();
function useCSS(rule) {
  useInsertionEffect(() => {
    // 앞서 설명했듯이 <style> 태그의 런타임 주입은 권장하지 않습니다.
    // 하지만 꼭 주입해야 한다면 useInsertionEffect에서 주입하는 것이 중요합니다.
    if (!isInserted.has(rule)) {
      isInserted.add(rule);
      document.head.appendChild(getStyleForRule(rule));
    }
  });
  return rule;
}

function Button() {
  const className = useCSS('...');
  return <div className={className} />;
}
```

`useEffect` 와 마찬가지로 `useInsertionEffect` 는 서버에서 실행되지 않는다. 서버에서 어떤 CSS 규칙이 사용되었는지 수집해야 하는 경우 렌더링 중에 수집할 수 있다:

```jsx
let collectedRulesSet = new Set();

function useCSS(rule) {
  if (typeof window === 'undefined') {
    collectedRulesSet.add(rule);
  }
  useInsertionEffect(() => {
    // ...
  });
  return rule;
}
```

### 이것이 렌더링 중에 스타일을 주입하거나 useLayoutEffect를 사용하는 것보다 어떻게 더 나은가요?

렌더링 중에 스타일을 주입하고 리액트가 non-blocking update를 처리하는 경우 브라우저는 컴포넌트 트리를 렌더링하는 동안 매 프레임마다 스타일을 다시 계산하므로 **매우 느릴 수 있다.**

`useInsertionEffect` 는 컴포넌트에서 다른 Effect가 실행될 때 `<style>` 태그가 주입되어 있음을 보장하기 때문에 `useLayoutEffect` 또는 `useEffect` 로 스타일을 주입하는 것보다 낫다. 그렇지 않으면 오래된 스타일로 인해 일반 Effects의 레이아웃 계산이 잘못될 수 있다.

| 용어 | 의미 |
| --- | --- |
| **non-blocking update** | UI 렌더링을 멈추지 않고, 낮은 우선순위의 작업은 나중에 처리하는 방식 |
| React에서의 목적 | 부드러운 UI, 렌더링 성능 향상 |
| 주의할 점 | 렌더링 중 스타일 주입과 함께 쓰면 브라우저 성능에 부하를 줄 수 있음 (→ `useInsertionEffect`처럼 타이밍 제어 필요) |
