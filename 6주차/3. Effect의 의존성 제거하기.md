# Effect의 의존성 제거하기

Effect를 작성하면 린터는 Effect의 의존성 목록에 Effect가 읽는 모든 반응형 값을 포함했는지 확인한다.

이렇게 하면 Effect가 컴포넌트의 최신 props 및 state와 동기화 상태를 유지할 수 있다.

불필요한 의존성으로 인해 Effect가 너무 자주 실행되거나 무한 루프를 생성할 수도 있다. Effect에서 불필요한 의존성을 검토하고 제거해보자.

## 의존성은 코드와 일치해야 한다.

Effect를 작성할 때는 먼저 Effect가 수행하기를 원하는 작업을 시작하고 중지하는 방법을 지정한다.

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
    // ...
}
```

그런 다음 Effect 의존성을 비워두면 린터가 올바른 의존성을 제안한다.

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
}
```

Effect는 반응형 값에 “반응”한다. `roomId` 는 반응형 값이므로, 린터는 이를 의존성으로 지정했는지 확인한다.

`roomId` 가 다른 값을 받으면 리액트는 Effect를 다시 동기화한다.

## 의존성을 제거하려면 의존성이 아님을 증명하세요.

Effect의 의존성을 “선택”할 수 없다는 점에 유의해라.

Effect의 코드에서 사용되는 모든 `반응형 값` 은 의존성 목록에 선언되어야 한다. 의존성 목록은 주변 코드에 의해 결정된다.

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) { // This is a reactive value
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // This Effect reads that reactive value
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ So you must specify that reactive value as a dependency of your Effect
  // ...
}
```

반응형 값에는 props와 컴포넌트 내부에서 직접 선언된 모든 변수 및 함수가 포함된다.

`roomId` 는 반응형 값이므로 의존성 목록에서 제거할 수 없다. 린터가 허용하지 않기 때문이다.

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // 🔴 React Hook useEffect has a missing dependency: 'roomId'
  // ...
}
```

**의존성을 제거하려면 해당 컴포넌트가 의존성이 될 필요가 없다는 것을 린터에 “증명”해야 한다.**

예를 들어 `roomId` 를 컴포넌트 밖으로 이동시켜서 반응형 값이 아니고 재렌더링 시에도 변경되지 않음을 증명할 수 있다.

```jsx
const serverUrl = 'https://localhost:1234';
const roomId = 'music'; // Not a reactive value anymore

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // ✅ All dependencies declared
  // ...
}
```

## 의존성을 변경하려면 코드를 변경하세요.

작업 흐름에서 패턴을 발견했을 수도 있다.

1. 먼저 Effect의 코드 또는 반응형 값 선언 방식을 변경한다.
2. 그런 다음, **변경한 코드에 맞게** 의존성을 조정한다.
3. 의존성 목록이 맘에 들지 않으면 **첫 번째 단계로 돌아간다.**

마지막 부분이 중요하다. 의존성을 변경하려면 먼저 주변 코드를 변경해야 한다.

의존성 목록은 Effect의 코드에서 사용하는 모든 반응형 값의 목록이라고 생각하면 된다.

### 주의하세요!

기존 코드베이스가 있는 경우 이와 같이 린터를 억제하는 Effect가 있을 수 있다.

```jsx
useEffect(() => {
  // ...
  // 🔴 Avoid suppressing the linter like this:
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
```

**의존성이 코드와 일치하지 않으면 버그가 발생할 위험이 매우 높다.**

린터를 억제하면 Effect가 의존하는 값에 대해 리액트에 거짓말을 하게 된다.

대신 다음에 소개할 기술을 사용해라.

## 불필요한 의존성 제거하기

코드를 반영하기 위해 Effect의 의존성을 조정할 때마다 의존성 목록을 살펴봐라.

이러한 의존성 중 하나라도 변경되면 Effect가 다시 실행되는 것이 합리적일까? 가끔 대답은 “아니오”가 될 수 있다.

- 다른 조건에서 Effect의 다른 부분을 다시 실행하고 싶을 수도 있다.
- 일부 의존성의 변경에 “반응”하지 않고 “최신 값”만 읽고 싶을 수 있다.
- 의존성은 객체나 함수이기 때문에 의도치 않게 너무 자주 변경될 수 있다.

올바른 해결책을 찾으려면 Effect에 대한 몇 가지 질문에 답해야 한다.

### 이 코드를 이벤트 핸들러로 옮겨야 하나요?

가장 먼저 고려해야 할 것은 이 코드가 Effect가 되어야 하는지 여부이다.

폼을 상상해 보자.

제출할 때 `submitted` state 변수를 `true` 로 설정한다. POST 요청을 보내고 알림을 표시해야 한다.

이 로직은 `submitted` 가 `true` 가 될 때 “반응”하는 Effect 안에 넣었다.

```jsx
function Form() {
  const [submitted, setSubmitted] = useState(false);

  useEffect(() => {
    if (submitted) {
      // 🔴 Avoid: Event-specific logic inside an Effect
      post('/api/register');
      showNotification('Successfully registered!');
    }
  }, [submitted]);

  function handleSubmit() {
    setSubmitted(true);
  }

  // ...
}
```

나중에 현재 테마에 따라 알림 메세지의 스타일을 지정하고 싶으므로 현재 테마를 읽는다.

`theme` 는 컴포넌트 본문에 선언되었기 때문에 이는 반응형 값이므로 의존성으로 추가한다.

```jsx
  const theme = useContext(ThemeContext);

  useEffect(() => {
    if (submitted) {
      // 🔴 Avoid: Event-specific logic inside an Effect
      post('/api/register');
      showNotification('Successfully registered!', theme);
    }
  }, [submitted, theme]); // ✅ All dependencies declared
```

이렇게 하면 버그가 발생하게 된다.

먼저 폼을 제출한 다음 어두운 테마와 밝은 테마 간 전환한다고 가정해 보겠다.

`theme` 는 변경되고 Effect가 다시 실행되어 동일한 알림이 다시 표시된다!

**여기서 문제는 이것이 애초에 Effect가 아니어야 한다는 점이다.**

이 POST 요청을 보내고 특정 상호작용인 폼 제출에 대한 응답으로 알림을 표시하고 싶다는 것이다.

특정 상호작용에 대한 응답으로 일부 코드를 실행하려면 해당 로직을 해당 이벤트 핸들러에 직접 넣어야 한다.

```jsx
  function handleSubmit() {
    // ✅ Good: Event-specific logic is called from event handlers
    post('/api/register');
    showNotification('Successfully registered!', theme);
  }
```

### Effect가 관련 없는 여러 가지 작업을 수행하나요?

다음 질문은 Effect가 서로 관련이 없는 여러 가지 작업을 수행하고 있는지 여부이다.

**서로 관련 없는 두 가지 동기화를 하면 문제가 생긴다.**

각 Effect는 독립적인 동기화 프로세스를 나타내야 한다. 중복이 걱정된다면 반복되는 로직을 커스텀 훅으로 추출하여 코드를 개선할 수 있다.

### 다음 State를 계산하기 위해 어떤 State를 읽고 있나요?

이 Effect는 새 메세지가 도착할 때마다 새로 생성된 배열로 `messages` state 변수를 업데이트 한다.

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    // ...
```

`messages` 변수를 사용하여 모든 기존 메세지로 시작하는 새 배열을 생성하고 마지막에 새 메세지를 추가한다.

하지만 `messages` 는 Effect에서 읽는 반응형 값이므로 의존성이어야 한다.

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId, messages]); // ✅ All dependencies declared
  // ...
```

하지만 `messages` 를 의존성으로 만들면 문제가 발생한다.

메세지를 수신할 때마다 `setMessages()` 는 컴포넌트가 수신된 메세지를 포함하는 새 `messages` 배열로 재렌더링하도록 한다.

하지만 이 Effect는 이제 `messages` 에 따라 달라지므로 Effect도 다시 동기화된다. 따라서 새 메세지가 올 때마다 채팅이 다시 연결된다.

이 문제를 해결하려면 Effect 내에서 `messages` 에서 읽지 말아야 한다. 대신 업데이터 함수를 `setMessages` 에 전달해라.

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
```

**이제 Effect가 `messages` 변수를 전혀 읽지 않는 것을 알 수 있다.**

`msgs => [...msgs, receivedMessage]` 와 같은 업데이터 함수만 전달하면 된다.

리액트는 업데이터 함수를 대기열에 넣고 다음 렌더링 중에 `msgs` 인수를 제공한다. 이 때문에 Effect 자체는 더 이상 `messages` 에 의존할 필요가 없다.

### 값의 변경에 ‘반응’하지 않고 값을 읽고 싶으신가요?

> **개발 중인 기술!**
이 섹션에서는 아직 안정된 버전의 리액트로 **출시되지 않은 실험적인 API**에 대해 설명한다.
> 

사용자가 새 메세지를 수신할 때 `isMuted` 가  `true` 가 아닌 경우 사운드를 재생하고 싶다고 가정해 보겠다.

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
      if (!isMuted) {
        playSound();
      }
    });
    return () => connection.disconnect();
  }, [roomId, isMuted]); // ✅ All dependencies declared
  // ...
```

그러면 `isMuted` 를 사용하기 때문에 의존성에 추가해야 한다.

문제는 `isMuted` 가 변경될 때마다 Effect가 다시 동기화되고 채팅에 다시 연결된다는 점이다. 이는 바람직한 사용자 경험이 아니다.

이 문제를 해결하려면 Effect에서 반응해서는 안되는 로직을 추출해야 한다.

이 Effect가 `isMuted` 의 변경에 “반응”하지 않기를 원한다. 이 비반응 로직을 Effect 이벤트로 옮기면 된다.

```jsx
import { useState, useEffect, useEffectEvent } from 'react';

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  const onMessage = useEffectEvent(receivedMessage => {
    setMessages(msgs => [...msgs, receivedMessage]);
    if (!isMuted) {
      playSound();
    }
  });

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      onMessage(receivedMessage);
    });
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
```

Effect 이벤트를 사용하면 Effect를 반응형 부분과 비반응형 부분으로 나눌 수 있다.

**이제 Effect 이벤트 내에서 `isMuted` 를 읽었으므로 Effect의 의존성이 될 필요가 없다.**

### props를 이벤트 핸들러로 감싸기

컴포넌트가 이벤트 핸들러를 props로 받을 때 비슷한 문제가 발생할 수 있다.

```jsx
function ChatRoom({ roomId, onReceiveMessage }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      onReceiveMessage(receivedMessage);
    });
    return () => connection.disconnect();
  }, [roomId, onReceiveMessage]); // ✅ All dependencies declared
  // ...
```

부모 컴포넌트가 렌더링할 때마다 다른 `onRecieveMessage` 함수를 전달한다고 가정해 보겠다.

```jsx
<ChatRoom
  roomId={roomId}
  onReceiveMessage={receivedMessage => {
    // ...
  }}
/>
```

`onReceiveMessage` 는 의존성이므로 부모가 재렌더링할 때마다 Effect가 다시 동기화된다. 그러면 채팅에 다시 연결되게 된다.

이 문제를 해결하려면 호출을 Effect 이벤트로 감싸야 한다.

```jsx
function ChatRoom({ roomId, onReceiveMessage }) {
  const [messages, setMessages] = useState([]);

  const onMessage = useEffectEvent(receivedMessage => {
    onReceiveMessage(receivedMessage);
  });

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      onMessage(receivedMessage);
    });
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
```

Effect 이벤트는 반응하지 않으므로 의존성으로 지정할 필요가 없다.

그 결과, 부모 컴포넌트가 재렌더링할 때마다 다른 함수를 전달하더라도 채팅이 더 이상 다시 연결되지 않는다.

### 일부 반응형 값이 의도치 않게 변경되나요?

Effect가 특정 값에 ‘반응’하기를 원하지만, 그 값이 원하는 것보다 더 자주 변경되어 사용자의 관점에서 실제 변경 사항을 반영하지 못할 수도 있다.

예를 들어 컴포넌트 본문에 `options` 객체를 생성한 다음 Effect 내부에서 해당 객체를 읽는다고 가정해 보겠다.

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // Temporarily disable the linter to demonstrate the problem
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const options = {
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}

```

위 코드에서 입력은 `message` state 변수만 업데이트한다. 이것은 채팅 연결에 영향이 있어서는 안된다.

하지만 `message` 를 업데이트할 때마다 컴포넌트가 재렌더링된다. 컴포넌트가 재렌더링되면 그 안에 있는 코드가 처음부터 다시 실행된다.

`ChatRoom` 컴포넌트를 재렌더링할 때마다 새로운 `options` 객체가 처음부터 새로 생성된다. 리액트는 `options` 객체가 마지막 렌더링 중에 생성된 `options` 객체와 다른 객체임을 인식한다.

그렇기 때문에 Effect를 다시 동기화하고 사용자가 입력할 때 채팅이 다시 연결된다.

**이 문제는 객체와 함수에만 영향을 준다.** 

**자바스크립트에서는 새로 생성된 객체와 함수가 다른 모든 객체와 구별되는 것으로 간주된다. 그 안의 내용이 동일할 수 있다는 것은 중요하지 않다.**

```jsx
// During the first render
const options1 = { serverUrl: 'https://localhost:1234', roomId: 'music' };

// During the next render
const options2 = { serverUrl: 'https://localhost:1234', roomId: 'music' };

// These are two different objects!
console.log(Object.is(options1, options2)); // false
```

**객체 및 함수 의존성으로 인해 Effect가 필요 이상으로 자주 재동기화될 수 있다.**

그렇기 때문에 가능하면 객체와 함수를 Effect의 의존성으로 사용하지 않는 것이 좋다. 대신 컴포넌트 외부나 Effect 내부로 이동하거나 원시 값을 추출해 봐라.

---

**객체가 props 및 state에 의존하지 않는 경우 해당 객체를 컴포넌트 외부로 이동할 수 있다.**

이는 함수에도 적용할 수 있다.

```jsx
const options = {
  serverUrl: 'https://localhost:1234',
  roomId: 'music'
};

function ChatRoom() {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, []); // ✅ All dependencies declared
  // ...
```

---

객체가 `roomId`  props처럼 재렌더링의 결과로 변경될 수 있는 반응형 값에 의존하는 경우, 컴포넌트 외부로 끌어낼 수 없다. **하지만 Effect의 코드 내부로 이동시킬 수는 있다.**

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
```

이제 `options` 는 Effect 내부에서 선언되었으므로 더 이상 Effect의 의존성이 아니다.

대신 Effect에서 사용하는 유일한 반응형은 `roomId`이다. `roomId` 는 객체나 함수가 아니기 때문에 의도치 않게 달라지지 않을 것이라고 확신할 수 있다.

자바스크립트에서 숫자와 문자열은 그 내용에 따라 비교된다.

```jsx
// During the first render
const roomId1 = 'music';

// During the next render
const roomId2 = 'music';

// These two strings are the same!
console.log(Object.is(roomId1, roomId2)); // true
```

이는 함수에서도 마찬가지이다.

```jsx
  useEffect(() => {
    function createOptions() {
      return {
        serverUrl: serverUrl,
        roomId: roomId
      };
    }

    const options = createOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
```

---

**가끔 props에서 객체를 받을 수도 있다.**

```jsx
function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]); // ✅ All dependencies declared
  // ...
```

렌더링 중에 부모 컴포넌트가 객체를 생성한다는 점이 위험하다.

```jsx
<ChatRoom
  roomId={roomId}
  options={{
    serverUrl: serverUrl,
    roomId: roomId
  }}
/>
```

이렇게 하면 부모 컴포넌트가 재렌더링할 때마다 Effect가 다시 연결된다. 이 문제를 해결하려면 Effect 외부의 객체에서 정보를 읽고 객체 및 함수 의존성을 피해라.

```jsx
function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  const { roomId, serverUrl } = options;
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ✅ All dependencies declared
  // ...
```

로직은 약간 반복적일 수 있다.

하지만 Effect가 실제로 어떤 정보에 의존하는지 매우 명확하게 할 수 있다.

부모 컴포넌트에 의해 의도치 않게 객체가 다시 생성된 경우 채팅이 다시 연결되지 않는다. 하지만 값이 변경되면 채팅이 다시 연결된다.

---

**함수에서도 동일한 접근 방식을 사용할 수 있다.**

예를 들어 부모 컴포넌트가 함수를 전달한다고 가정해 보겠다.

```jsx
<ChatRoom
  roomId={roomId}
  getOptions={() => {
    return {
      serverUrl: serverUrl,
      roomId: roomId
    };
  }}
/>
```

의존성을 만들지 않으려면 Effect 외부에서 호출해라.

이렇게 하면 객체가 아니며 Effect 내부에서 읽을 수 있는 `roomId`  및 `serverUrl`  값을 얻을 수 있다.

```jsx
function ChatRoom({ getOptions }) {
  const [message, setMessage] = useState('');

  const { roomId, serverUrl } = getOptions();
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ✅ All dependencies declared
  // ...
```

이는 렌더링 중에 호출해도 안전하므로 순수 함수에서만 작동한다.

함수가 이벤트 핸들러지만 변경 사항으로 인해 Effect가 다시 동기화되는 것을 원하지 않는 경우, 대신 Effect 이벤트로 함수를 감싸라.
