# 커스텀 Hook으로 로직 재사용하기
리액트는 `useState` , `useContext` , 그리고 `useEffect` 같이 몇몇 내재하고 있는 Hook이 존재한다.

가끔 조금 더 구체적인 목적을 가진 Hook이 존재하길 바랄 때도 있다. 예를 들어, 데이터를 가져온다던가, 사용자가 온라인 상태인지 계속 확인한다든가, 혹은 채팅방에 연결하기 위한 목적들처럼 말이다.

리액트에서 다음과 같은 Hook을 찾기는 어렵지만, 애플리케이션의 필요에 알맞는 본인만의 Hook을 만들 수 있다.

## 커스텀 Hook: 컴포넌트간 로직 공유하기

네트워크에 크게 의존하는 앱(대부분의 앱이 그렇듯)을 개발 중이라고 생각해 보자.

사용자가 앱을 사용하는 동안 네트워크 가 갑자기 사라진다면, 사용자에게 경고하고 싶을 것이다.

1. 네트워크가 온라인 상태인지 아닌지 추적하는 하나의 state
2. 전역 `online` , `offline` 이벤트를 구독하고, 이에 맞춰 state를 업데이트하는 Effect

두 가지 요소는 컴포넌트가 네트워크 상태와 동기화되도록 한다.

```tsx
import { useState, useEffect } from 'react';

export default function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return <h1>{isOnline ? '✅ 온라인' : '❌ 연결 안 됨'}</h1>;
}

```

이제 다른 컴포넌트에서 같은 로직을 또 사용한다고 상상해 봐라.

네트워크가 꺼졌을 때, “저장” 대신 “재연결 중…”을 보여주는 비활성화된 저장 버튼을 구현하고 싶다고 가정해 보자.

구현하기 위해, 앞서 사용한 `isOnline` state과 Effect를 `SaveButton` 안에 복사 붙여넣기 할 수 있다.

```tsx
import { useState, useEffect } from 'react';

export default function SaveButton() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  function handleSaveClick() {
    console.log('✅ 진행사항 저장됨');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? '진행사항 저장' : '재연결 중...'}
    </button>
  );
}

```

위의 두 컴포넌트는 잘 작동한다. 하지만 둘 사이의 로직이 중복되는 게 아쉽다.

로직을 재사용해 보자.

## 컴포넌트로부터 커스텀 Hook 추출하기

`useState`  그리고 `useEffect` 와 비슷한 내장된 `useOnlineStatus` Hook이 있다고 상상해 보자.

그럼 두 컴포넌트를 단순화할 수 있고, 둘 간의 중복을 제거할 수 있다.

```tsx
function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '✅ 온라인' : '❌ 연결 안 됨'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('✅ 진행사항 저장됨');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? '진행사항 저장' : '재연결 중...'}
    </button>
  );
}
```

내장된 훅이 없다 해도, 스스로 만들어 낼 수 있다.

`useOnlineStatus` 함수를 정의하고, 앞서 작성한 컴포넌트들의 중복되는 코드를 바꿔라.

```tsx
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return isOnline;
}
```

함수의 마지막에 `isOnline` 을 반환하면, 그 값을 읽을 수 있게 해준다.

이제 컴포넌트는 반복되는 로직이 많지 않게 되었다.

**중요한 건, 두 컴포넌트 내부 코드가 어떻게 그것을 하는지보다 그들이 무엇을 하려는지에 대해 설명하고 있다는 점이다.**

커스텀 Hook을 만들어 낼 때, 브라우저 API나 외부 시스템과 소통하는 방법과 같은 불필요한 세부 사항을 숨길 수 있다.

컴포넌트의 코드는 목적만을 나타낼 뿐 실행 방법에 대해선 나타내지 않는다.

## Hook의 이름은 항상 `use` 로 시작해야 한다.

리액트 애플리케이션은 여러 컴포넌트로 만들어진다. 컴포넌트들은 내장되거나 직접 작성된 Hook으로 만들어진다.

본인만의 Hook을 만들 때, 다음의 작명 규칙을 준수해야 한다.

1. **리액트 컴포넌트의 이름은 항상 대문자로 시작해야 한다.**
또한 리액트 컴포넌트는 JSX처럼 어떻게 보이는지 리액트가 알 수 있는 무언가를 반환해야 한다.
2. **Hook의 이름은 `use` 뒤에 대문자로 시작해야 한다.**
Hook들은 어떤 값이든 반환할 수 있다.

이러한 규칙들은 컴포넌트를 볼 때, 어디에 state Effect 및 다른 리액트 기능들이 “숨어”있는지 알 수 있게 해준다.

### 중요합니다!

linter가 리액트에 맞춰있다면, 작명 규칙을 지키게 한다.

위의 코드로 다시 올라가 `useOnlineStatus` 를 `getOnlineStatus` 로 바꿔봐라. linter가 내부에서 `useState` 나 `useEffect` 를 사용하는 것을 더 이상 허용하지 않을 것이다.

오로지 Hook과 컴포넌트만 다른 Hook을 사용할 수 있다.

### 렌더링 중에 호출되는 모든 함수는 use 접두사로 시작해야 하나요?

아니다. Hook을 호출하지 않는 함수는 Hook일 필요가 없다.

함수가 어떤 Hook도 호출하지 않는다면, `use` 를 이름 앞에 작성하는 것을 피해라.

대신, `use` 없이 일반적인 함수로 작성해라. 예를 들어 `useSorted` 가 Hook을 호출하지 않는다면 `getSorted` 로 변경할 수 있다.

```tsx
// 🔴 안 좋은 예시 : Hook을 사용하고 있지 않는 Hook.
function useSorted(items) {
  return items.slice().sort();
}

// ✅ 좋은 예시 : Hook을 사용하지 않는 일반 함수.
function getSorted(items) {
  return items.slice().sort();
}
```

다음의 예는 조건문 뿐만 아니라 어디든 일반 함수를 사용할 수 있다는 것을 보여준다.

```tsx
function List({ items, shouldSort }) {
  let displayedItems = items;
  if (shouldSort) {
    // ✅ getSorted()가 Hook이 아니기 때문에 조건에 따라 호출할 수 있습니다.
    displayedItems = getSorted(items);
  }
  // ...
}
```

적어도 하나의 Hook을 내부에서 사용한다면 반드시 함수 앞에 `use` 를 작성해야 한다.

```tsx
// ✅ 좋은 예시 : Hook을 사용하는 Hook
function useAuth() {
  return useContext(Auth);
}
```

기술적으로 이건 리액트에 의해 강요되진 않는다.

원칙적으로 다른 Hook을 사용하지 않는 Hook을 만들 수 있다. 이건 혼란스럽고 제한되기 때문에 해당 방식은 피하는 것이 좋다.

하지만, 매우 드물게 이런 방식이 도움이 될 때도 있다.

예를 들어 지금 당장은 함수에서 어떤 Hook도 사용하지 않지만, 미래에 Hook을 호출할 계획이 있다면 `use` 를 앞에 붙여 이름 짓는 것이 가능하다.

```tsx
// ✅ 좋은 예시 : 추후에 다른 Hook을 사용할 가능성이 있는 Hook
function useAuth() {
  // TODO: 인증이 수행될 때 해당 코드를 useContext(Auth)를 반환하는 코드로 바꾸기
  return TEST_USER;
}
```

그럼, 컴포넌트는 조건에 따라 호출할 수 없게 된다. 이건 실제로 Hook을 내부에 추가해 호출할 때 매우 중요하다.

지금이든 나중이든 Hook을 내부에 사용할 계획이 없다면, Hook으로 만들지 마라.

## 커스텀 Hook은 state 그 자체를 공유하는게 아닌 state 저장 로직을 공유하도록 합니다.

앞선 예시에서, 우리가 네트워크를 껐다 켰을 때 양쪽 컴포넌트가 함께 업데이트되었다.

그렇다고 해서 `isOnline` state 변수가 두 컴포넌트 간 공유되었다고 생각하면 안된다.

```tsx
function StatusBar() {
  const isOnline = useOnlineStatus();
  // ...
}

function SaveButton() {
  const isOnline = useOnlineStatus();
  // ...
}
```

우리가 중복된 부분을 걷어내기 전에도 동일하게 동작한다.

```tsx
function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    // ...
  }, []);
  // ...
}

function SaveButton() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    // ...
  }, []);
  // ...
}
```

완전히 독립적인 두 state 벼수와 Effect가 있음을 확인할 수 있다.

그들은 우리가 동일한 외부 변수를 동기화했기 때문에 같은 시간에 같은 값을 가지고 있을 뿐이다.

이걸 더 잘 표현하기 위해 다른 예시가 필요하다.

다음 `Form` 컴포넌트를 살펴봐라.

```tsx
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('Mary');
  const [lastName, setLastName] = useState('Poppins');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <label>
        First name:
        <input value={firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={lastName} onChange={handleLastNameChange} />
      </label>
      <p><b>Good morning, {firstName} {lastName}.</b></p>
    </>
  );
}

```

각각의 폼 입력에 반복되는 로직이 있다.

1. state가 존재한다. (`firstName` , `lastName` )
2. 변화를 다루는 함수가 존재한다. (`handleFirstNameChange` , `handleLastNameChange` )
3. 해당 입력에 대한 `value` 와 `onChange` 의 속성을 지정하는 JSX가 존재한다.

`useFormInput` 커스텀 Hook을 통해 반복되는 로직을 추출할 수 있다.

```tsx
//App.js
import { useFormInput } from './useFormInput.js';

export default function Form() {
  const firstNameProps = useFormInput('Mary');
  const lastNameProps = useFormInput('Poppins');

  return (
    <>
      <label>
        First name:
        <input {...firstNameProps} />
      </label>
      <label>
        Last name:
        <input {...lastNameProps} />
      </label>
      <p><b>Good morning, {firstNameProps.value} {lastNameProps.value}.</b></p>
    </>
  );
}

```

```tsx
//useFormInput.js
import { useState } from 'react';

export function useFormInput(initialValue) {
  const [value, setValue] = useState(initialValue);

  function handleChange(e) {
    setValue(e.target.value);
  }

  const inputProps = {
    value: value,
    onChange: handleChange
  };

  return inputProps;
}

```

`value` 라고 불리는 state 변수가 한 번만 정의된다는 것을 기억해라.

이와 달리, `Form` 컴포넌트는 `useFormInput` 을 **두 번** 호출한다.

```tsx
function Form() {
  const firstNameProps = useFormInput('Mary');
  const lastNameProps = useFormInput('Poppins');
  // ...
```

위의 예시는 왜 두 개의 다른 state 변수를 정의하는 식으로 동작하는지 보여준다.

**커스텀 Hook은 우리가 state 그 자체가 아닌 state 저장 로직을 공유하도록 해준다. 같은 Hook을 호출하더라도 각각의 Hook 호출은 완전히 독립되어 있다.**

이것이 위의 두 코드가 완전히 같은 이유이다.

대신 여러 컴포넌트 간 state 자체를 공유할 필요가 있다면, state를 위로 올려 전달해라.

## Hook 사이에 상호작용하는 값 전달하기

커스텀 Hook 안의 코드는 컴포넌트가 재렌더링될 때마다 다시 돌아갈 거다.

이게 바로 Hook이 순수해야 하는 이유이다. 커스텀 Hook을 컴포넌트 본체의 한 부분이라고 생각하면 좋다.

커스텀 Hook이 컴포넌트와 함께 재렌더링된다면, 항상 가장 최신의 props와 state를 전달받을 것이다.

## 커스텀 Hook에 이벤트 핸들러 넘겨주기

> **개발 중인 기술!**
이 섹션은 리액트의 안정화 버전에 아직 반영되지 않은 실험적인 API를 설명하고 있다.
> 

커스텀 Hook에서 함수를 prop으로 받아와 사용하고 싶다면, 함수를 useEffectEvent로 감싸 받는 것이 좋다.

함수를 넘겨주는 컴포넌트가 재렌더링되면 함수도 새로 전달되면서 커스텀 Hook 속 Effect가 불필요하게 재실행될 수 있기 때문이다.

## 언제 커스텀 Hook을 사용해야 하는지

모든 자잘한 중복되는 코드들까지 커스텀 Hook으로 분리할 필요는 없다.

하지만 Effect를 사용하든 사용하지 않든, 커스텀 Hook 안에 그것을 감싸는 게 좋은지 아닌지 고려해라. Effect를 자주 쓸 필요가 없을지 모른다.

만약 Effect를 사용한다면, 그건 외부 시스템과 동기화한다던가 리액트가 내장하지 않은 API를 위해 무언가를 하는 등 “리액트를 벗어나기” 위함일 것이다.

커스텀 Hook으로 감싸는 것은 목적을 정확하게 전달하고 어떻게 데이터가 그것을 통해 흐르는지 알 수 있게 한다.

커스텀 Hook으로 추출하는 것은 데이터의 흐름을 명확하게 해주고, 컴포넌트에 불필요한 의존성을 추가하는 것을 막을 수 있다.

### 커스텀 Hook이 구체적인 고급 사용 사례에 집중하도록 하기

커스텀 Hook의 이름을 고르는 과정에서 고분분투한다면, 그건 사용하는 Effect가 컴포넌트 로직의 일부분에 너무 결합하여 있다는 의미일 것이다.

그리고 아직 분리될 준비가 안된 것이다.

이상적으로 커스텀 Hook의 이름은 코드를 자주 작성하는 사람이 아니더라도 커스텀 Hook이 무슨 일을 하고, 무엇을 props로 받고, 무엇을 반환하는지 알 수 있도록 아주 명확해야 한다.

```tsx
✅ useData(url)
✅ useImpressionLog(eventName, extraData)
✅ useChatRoom(options)
```

외부 시스템과 동기화할 때, 커스텀 Hook의 이름은 좀 더 기술적이고 해당 시스템을 특정하는 용어를 사용하면 좋다.

해당 시스템에 친숙한 사람에게도 명확한 이름이라면 좋다.

```jsx
✅ useMediaQuery(query)
✅ useSocket(url)
✅ useIntersectionObserver(ref, options)
```

**커스텀 Hook이 구체적인 고급 사용 사례에 집중할 수 있도록 해라.**

`useEffect` API 그 자체를 위한 대책이나 편리하게 감싸는 용도로 동작하는 커스텀 “생명 주기” Hook을 생성하거나 사용하는 것을 피해라.

```jsx
🔴 useMount(fn)
🔴 useEffectOnce(fn)
🔴 useUpdateEffect(fn)
```

예를 들어, 이 `useMount` Hook은 코드가 “마운트 시”에만 동작하는 것을 확인하기 위해 만들어졌다.

```jsx
function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  // 🔴 안 좋은 예 : 커스텀 "생명 주기" Hook을 사용
  useMount(() => {
    const connection = createConnection({ roomId, serverUrl });
    connection.connect();

    post('/analytics/event', { eventName: 'visit_chat' });
  });
  // ...
}

// 🔴 안 좋은 예 : 커스텀 "생명 주기" Hook을 생성
function useMount(fn) {
  useEffect(() => {
    fn();
  }, []); // 🔴 React Hook useEffect은 'fn'의 의존성을 갖고 있지 않음.
}
```

**`useMount` 과 같은 커스텀 “생명 주기” Hook은 전형적인 리액트와 맞지 않는다.**

예를 들어 이 코드 예시는 문제가 있지만(`roomId` 나 `serverUrl` 의 변화에 반응하지 않음), 린터는 오직 직접적인 `useEffect` 호출만 체크하기 때문에 경고하지 않는다.

린터는 Hook에 대해 모르고 있다!

Effect를 작성할 때, React API를 직접적으로 사용해라.

```jsx
function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  // ✅ 좋은 예시 : 두 Effect는 목적에 따라 나뉘어 있습니다.

  useEffect(() => {
    const connection = createConnection({ serverUrl, roomId });
    connection.connect();
    return () => connection.disconnect();
  }, [serverUrl, roomId]);

  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_chat', roomId });
  }, [roomId]);

  // ...
}
```

그렇게 되면 (그럴 필요는 없지만) 커스텀 Hook을 서로 다른 고급 사용 예시에 따라 분리할 수 있다.

```jsx
function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  // ✅ Great: custom Hooks named after their purpose
  useChatRoom({ serverUrl, roomId });
  useImpressionLog('visit_chat', { roomId });
  // ...
}
```

**좋은 커스텀 Hook은 호출 코드가 하는 일을 제한하면서 좀 더 선언적으로 만들 수 있다.**

예를 들어, `useChatRoom(options)` 은 오직 채팅방과 연결할 수 있지만, `useImpressionLog(eventName, extraData)` 은 애널리틱스에만 노출된 기록을 보낼 수 있다.

커스텀 Hook API가 사용 사례를 제한하지 않고 너무 추상적이라면, 장기적으로는 그것이 해결할 수 있는 것보다 더 많은 문제를 만들 가능성이 높다.

## 커스텀 Hook은 더 나은 패턴으로 변경할 수 있도록 도와준다.

Effect는 탈출구이다.

“리액트에서 벗어나”는 것이 필요할 때나 사용 시에 괜찮은 내장된 해결 방법이 없는 경우, 사용한다.

리액트 팀의 목표는 더 구체적인 문제에 더 구체적인 해결 방법을 제공해 앱에 있는 Effect의 숫자를 점차 최소한으로 줄이는 것이다.

커스텀 Hook으로 Effect를 감싸는 것은 이런 해결 방법들이 가능해질 때 코드를 쉽게 업그레이드할 수 있게 해준다.

```jsx
import { useState, useEffect } from 'react';

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return isOnline;
}

```

위의 예시에서 `useOnlineStatus` 는 한 쌍의 `useState` 와 `useEffect` 와 함께 실행된다.

하지만 이건 가장 좋은 해결 방법은 아니다. 이 해결 방법이 고려하지 못한 수많은 예외 상황이 존재한다.

예를 들어 컴포넌트가 마운트 됐을 때, `isOnline` 이 이미 `true` 라고 가정한다. 하지만 이것은 네트워크가 이미 꺼졌을 때 틀린 가정이 된다.

이런 상황을 확인하기 위해 브라우저 [`navigator.onLine`](http://navigator.onLine) API를 사용할 수 있다. 하지만 이걸 직접적으로 사용하게 되면 초기 HTML을 생성하기 위한 서버에선 동작하지 않는다.

이 코드는 보완되어야 한다.

리액트는 이런 모든 문제를 신경 써주는 `useSyncExternalStore` 라고 불리는 섬세한 API를 포함한다.

여기에 새 API의 장점을 가지고 다시 쓰인 `OnlineStatus` 이 있다.

```jsx
import { useSyncExternalStore } from 'react';

function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}

export function useOnlineStatus() {
  return useSyncExternalStore(
    subscribe,
    () => navigator.onLine, // 클라이언트의 값을 받아오는 방법
    () => true // 서버의 값을 받아오는 방법
  );
}
```

어떻게 이 변경을 하기 위해 다른 컴포넌트들을 변경하지 않아도 되는지 알아보자.

```jsx
function StatusBar() {
  const isOnline = useOnlineStatus();
  // ...
}

function SaveButton() {
  const isOnline = useOnlineStatus();
  // ...
}
```

커스텀 Hook으로 Effect를 감싸는 것이 종종 유용한 이유는 다음과 같다:

1. 매우 명확하게 EFfect로 주고받는 데이터 흐름을 만들 때
2. 컴포넌트가 Effect의 정확한 실행보다 목적에 집중하도록 할 때
3. 리액트가 새 기능을 추가할 때, 다른 컴포넌트의 변경 없이 이 Effect를 삭제할 수 있을 때

디자인 시스템과 마찬가지로, 앱의 컴포넌트에서 일반적인 관용구를 추출하여 커스텀 Hook으로 만드는 것이 도움이 될 수 있다.

이렇게 하면 컴포넌트의 코드가 의도에 집중할 수 있고, Effect를 자주 작성하지 않아도 된다. 

리액트 커뮤니티에서 많은 훌륭한 커스텀 Hook을 관리하고 있다!

### 리액트가 데이터 패칭을 위한 내부 해결책을 제공할까요?

아직 세부적인 사항을 작업 중이지만, 앞으로는 이와 같이 데이터를 가져오도록 작성하게 될 것으로 예상된다.

```jsx
import { use } from 'react'; // 아직 사용 불가능합니다!

function ShippingForm({ country }) {
  const cities = use(fetch(`/api/cities?country=${country}`));
  const [city, setCity] = useState(null);
  const areas = city ? use(fetch(`/api/areas?city=${city}`)) : null;
  // ...
```

앱에 `useData` 과 같은 커스텀 Hook을 사용한다면, 모든 컴포넌트에 수동적으로 Effect를 작성하는 것보다 최종적으로 권장되는 접근 방식으로 변경하는 것이 더 적은 변경이 요구된다.

그러나 이전의 접근 방식도 충분히 잘 동작하기 때문에 Effect 사용을 즐긴다면 그렇게 사용해도 된다!

## 여러 방법이 존재합니다.

브라우저의 `requestAnimationFrame` API를 이용해 **처음부터** 페이드 인 애니메이션을 구현한다고 생각해 보자.

아마 애니메이션을 반복시키기 위해 Effect부터 작성할 것이다.

각각의 애니메이션 프레임 동안 참조해 둔 ref DOM 노드의 투명도를 `1` 에 도달할 때까지 변경할 수 있다.

- 코드
    
    ```jsx
    import { useState, useEffect, useRef } from 'react';
    
    function Welcome() {
      const ref = useRef(null);
    
      useEffect(() => {
        const duration = 1000;
        const node = ref.current;
    
        let startTime = performance.now();
        let frameId = null;
    
        function onFrame(now) {
          const timePassed = now - startTime;
          const progress = Math.min(timePassed / duration, 1);
          onProgress(progress);
          if (progress < 1) {
            // 아직 그려야 할 프레임이 많습니다.
            frameId = requestAnimationFrame(onFrame);
          }
        }
    
        function onProgress(progress) {
          node.style.opacity = progress;
        }
    
        function start() {
          onProgress(0);
          startTime = performance.now();
          frameId = requestAnimationFrame(onFrame);
        }
    
        function stop() {
          cancelAnimationFrame(frameId);
          startTime = null;
          frameId = null;
        }
    
        start();
        return () => stop();
      }, []);
    
      return (
        <h1 className="welcome" ref={ref}>
          Welcome
        </h1>
      );
    }
    
    export default function App() {
      const [show, setShow] = useState(false);
      return (
        <>
          <button onClick={() => setShow(!show)}>
            {show ? 'Remove' : 'Show'}
          </button>
          <hr />
          {show && <Welcome />}
        </>
      );
    }
    
    ```
    

이 컴포넌트의 가독성을 위해 로직을 추출해 `useFadeIn` 커스텀 Hook을 만들어 보자.

- `App.js`
    
    ```jsx
    //App.js
    import { useState, useEffect, useRef } from 'react';
    
    function Welcome() {
      const ref = useRef(null);
    
      useEffect(() => {
        const duration = 1000;
        const node = ref.current;
    
        let startTime = performance.now();
        let frameId = null;
    
        function onFrame(now) {
          const timePassed = now - startTime;
          const progress = Math.min(timePassed / duration, 1);
          onProgress(progress);
          if (progress < 1) {
            // 아직 그려야 할 프레임이 많습니다.
            frameId = requestAnimationFrame(onFrame);
          }
        }
    
        function onProgress(progress) {
          node.style.opacity = progress;
        }
    
        function start() {
          onProgress(0);
          startTime = performance.now();
          frameId = requestAnimationFrame(onFrame);
        }
    
        function stop() {
          cancelAnimationFrame(frameId);
          startTime = null;
          frameId = null;
        }
    
        start();
        return () => stop();
      }, []);
    
      return (
        <h1 className="welcome" ref={ref}>
          Welcome
        </h1>
      );
    }
    
    export default function App() {
      const [show, setShow] = useState(false);
      return (
        <>
          <button onClick={() => setShow(!show)}>
            {show ? 'Remove' : 'Show'}
          </button>
          <hr />
          {show && <Welcome />}
        </>
      );
    }
    
    ```
    
- `useFadeIn.js`
    
    ```jsx
    import { useEffect } from 'react';
    
    export function useFadeIn(ref, duration) {
      useEffect(() => {
        const node = ref.current;
    
        let startTime = performance.now();
        let frameId = null;
    
        function onFrame(now) {
          const timePassed = now - startTime;
          const progress = Math.min(timePassed / duration, 1);
          onProgress(progress);
          if (progress < 1) {
            // 아직 그려야 할 프레임이 많습니다.
            frameId = requestAnimationFrame(onFrame);
          }
        }
    
        function onProgress(progress) {
          node.style.opacity = progress;
        }
    
        function start() {
          onProgress(0);
          startTime = performance.now();
          frameId = requestAnimationFrame(onFrame);
        }
    
        function stop() {
          cancelAnimationFrame(frameId);
          startTime = null;
          frameId = null;
        }
    
        start();
        return () => stop();
      }, [ref, duration]);
    }
    
    ```
    

`useFadeIn` 코드를 유지할 수도 있지만 더 리펙토링할 수도 있다.

예를 들어 `useFadeIn` 밖으로 반복 설정 로직을 빼내 `useAnimationLoop`  커스텀 Hook으로 만들 수 있다.

- `useFadeIn.js`
    
    ```jsx
    import { useState, useEffect } from 'react';
    import { experimental_useEffectEvent as useEffectEvent } from 'react';
    
    export function useFadeIn(ref, duration) {
      const [isRunning, setIsRunning] = useState(true);
    
      useAnimationLoop(isRunning, (timePassed) => {
        const progress = Math.min(timePassed / duration, 1);
        ref.current.style.opacity = progress;
        if (progress === 1) {
          setIsRunning(false);
        }
      });
    }
    
    function useAnimationLoop(isRunning, drawFrame) {
      const onFrame = useEffectEvent(drawFrame);
    
      useEffect(() => {
        if (!isRunning) {
          return;
        }
    
        const startTime = performance.now();
        let frameId = null;
    
        function tick(now) {
          const timePassed = now - startTime;
          onFrame(timePassed);
          frameId = requestAnimationFrame(tick);
        }
    
        tick();
        return () => cancelAnimationFrame(frameId);
      }, [isRunning]);
    }
    
    ```
    

하지만 반드시 이처럼 작성할 필요는 없다.

일반 함수와 마찬가지로 궁극적으로 코드의 여러 부분 사이의 경계를 어디에 그릴지 결정해야 한다.

매우 다르게 접근할 수도 있다. Effect 내부의 로직을 유지하는 대신, 대부분의 중요한 로직을 자바스크립트 Class 내부로 이동시킬 수 있다.

- `useFadeIn.js`
    
    ```jsx
    import { useState, useEffect } from 'react';
    import { FadeInAnimation } from './animation.js';
    
    export function useFadeIn(ref, duration) {
      useEffect(() => {
        const animation = new FadeInAnimation(ref.current);
        animation.start(duration);
        return () => {
          animation.stop();
        };
      }, [ref, duration]);
    }
    
    ```
    
- `animartion.js`
    
    ```jsx
    export class FadeInAnimation {
      constructor(node) {
        this.node = node;
      }
      start(duration) {
        this.duration = duration;
        this.onProgress(0);
        this.startTime = performance.now();
        this.frameId = requestAnimationFrame(() => this.onFrame());
      }
      onFrame() {
        const timePassed = performance.now() - this.startTime;
        const progress = Math.min(timePassed / this.duration, 1);
        this.onProgress(progress);
        if (progress === 1) {
          this.stop();
        } else {
          // We still have more frames to paint
          this.frameId = requestAnimationFrame(() => this.onFrame());
        }
      }
      onProgress(progress) {
        this.node.style.opacity = progress;
      }
      stop() {
        cancelAnimationFrame(this.frameId);
        this.startTime = null;
        this.frameId = null;
        this.duration = 0;
      }
    }
    
    ```
    

Effect는 외부 시스템과 리액트를 연결할 수 있게 해준다.

예를 들어 여러 애니메이션을 연결하는 것처럼 Effect 간의 조정이 더 많이 필요할수록, 위의 코드 예시처럼 Effect와 Hook 밖으로 로직을 완전히 분리하는 것이 합리적이다.

그렇게 분리한 코드는 “외부 시스템”이 될 것이다.

Effect는 리액트 밖으로 내보낸 시스템에 메세지만 보내면 되기 때문에 이런 방식은 Effect가 심플한 상태를 유지하도록 한다.

위의 예시는 페이드인 로직이 자바스크립트로 작성되어야 하는 경우라고 가정한다.

하지만 이런 특정 페이드인 애니메이션은 일반 CSS 애니메이션으로 구현하는 것이 더 간단하고 훨씬 효율적이다.

- `App.js`
    
    ```jsx
    import { useState, useEffect, useRef } from 'react';
    import './welcome.css';
    
    function Welcome() {
      return (
        <h1 className="welcome">
          Welcome
        </h1>
      );
    }
    
    export default function App() {
      const [show, setShow] = useState(false);
      return (
        <>
          <button onClick={() => setShow(!show)}>
            {show ? 'Remove' : 'Show'}
          </button>
          <hr />
          {show && <Welcome />}
        </>
      );
    }
    
    ```
    
- `welcome.css`
    
    ```jsx
    .welcome {
      color: white;
      padding: 50px;
      text-align: center;
      font-size: 50px;
      background-image: radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%);
    
      animation: fadeIn 1000ms;
    }
    
    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }
    
    ```
    

가끔은 Hook이 필요하지 않을 수 있다!
