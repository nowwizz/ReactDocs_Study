# React Effect의 생명주기

effects는 컴포넌트와 다른 생명주기를 가진다.

컴포넌트는 마운트, 업데이트 또는 마운트 해제를 할 수 있다.

effect는 동기화를 시작하고 나중에 동기화를 중지하는 두 가지 작업만 할 수 있다. 이 사이클은 시간이 지남에 따라 변하는 props와 state에 의존하는 effect의 경우 여러 번 발생할 수 있다.

리액트는 effect의 의존성을 올바르게 지정했는지 확인하는 린터 규칙을 제공한다. 이렇게 하면 effect가 최신 props와 state에 동기화된다.

---

## effect의 생명주기

모든 리액트 컴포넌트는 동일한 생명주기를 가진다.

- 컴포넌트는 화면에 추가될 때 마운트된다.
- 컴포넌트는 일반적으로 상호작용에 대한 응답으로 새로운 props나 state를 수신하면 업데이트된다.
- 컴포넌트가 화면에서 제거되면 마운트가 해제된다.

**컴포넌트에 대해 생각하기에는 좋지만 effects에 대해서는 생각하지 않는 게 좋다.**

대신 컴포넌트의 생명주기와 독립적으로 각 effect를 생각해 봐라. effect는 외부 시스템을 현재 props 및 state로 동기화하는 방법을 설명한다.

코드가 변경되면 동기화를 더 자주 또는 덜 자주 수행해야 한다.

이 점을 설명하기 위해 컴포넌트를 채팅 서버에 연결하는 effect를 예로 들어보겠다.

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

effect의 본문에는 **동기화 시작, 동기화 중지(반환된 cleanup)** 방법이 명시되어 있다.

```jsx
    // ...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
    // ...
```

직관적으로 리액트는 컴포넌트가 마운트될 때 **동기화를 시작**하고 컴포넌트가 마운트 해제될 때 동기화를 주지할 것이라고 생각할 수 있다.

하지만 때로는 컴포넌트가 마운트된 상태에서 동기화를 여러 번 시작하고 중지해야 할 수도 있다.

이러한 동작이 필요한 이유와 발생 시기, 그리고 이러한 동작을 제어할 수 있는 방법을 살펴보겠다.

### 중요합니다!

일부 effects는 cleanup 함수를 전혀 반환하지 않는다. 대부분의 경우 함수를 반환하고 싶겠지만, 그렇지 않은 경우 리액트는 빈 cleanup 함수를 반환한 것처럼 동작한다.

---

## 동기화가 두 번 이상 수행되어야 하는 이유

이 `ChatRoom` 컴포넌트가 사용자가 드롭다운에서 선택한 `roomId` prop을 받는다고 가정해보자.

처음에 사용자가 `“general”` 대화방을 `roomId` 로 선택했다고 가정해보자. 앱에 `“general”` 채팅방이 표시된다.

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId /* "general" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}
```

UI가 표시되면 리액트가 effect를 실행하여 동기화를 시작한다. `“general”` 방에 연결된다.

```jsx
function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // "general" 방에 연결
    connection.connect();
    return () => {
      connection.disconnect(); // "general" 방에서 연결 해제
    };
  }, [roomId]);
  // ...
```

지금까지는 괜찮다.

나중에 사용자가 드롭다운에서 다른 방을 선택한다. 먼저 리액트가 UI를 업데이트한다.

```jsx
function ChatRoom({ roomId /* "travel" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}
```

다음에 어떤 일이 일어날지 생각해 봐라.

사용자는 UI에서 `“travel”` 이 선택된 대화방임을 알 수 있다. 그러나 지난번에 실행된 effect는 여전히 “general” 대화방에 연결되어 있다.

**`roomId` prop이 변경되었기 때문에 그때 effect가 수행한 작업 (”general” 방에 연결)이 더 이상 UI와 일치하지 않는다.**

이 시점에서 리액트가 두 가지 작업을 수행하기를 원한다.

1. 이전 roomId와의 동기화를 중지한다.
2. 새 roomId와 동기화 시작

다행히도, 우리는 이미 이 두 가지를 수행하는 방법을 리액트에서 배웠다.

effect의 본문에는 동기화를 시작하는 방법이 명시되어 있고, cleanup 함수에는 동기화를 중지하는 방법이 명시되어 있다.

이제 리액트가 해야 할 일은 올바른 순서로 올바른 props와 state로 호출하기만 하면 된다.

## 리액트가 effect를 재동기화하는 방법

`ChatRoom` 컴포넌트가 `roomId` prop에 새로운 값을 받았다는 것을 기억해라.

다른 방에 다시 연결하려면 리액트가 effect를 다시 동기화해야 한다.

**동기화를 중지**하기 위해 리액트는 `“general”` 방에 연결한 후 effect가 반환한 cleanup 함수를 호출한다.

`roomId` 가 `“general”` 이었기 때문에, cleanup 함수는 `“general”` 방에서 연결을 끊는다.

```jsx
function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // "general" 방에 연결
    connection.connect();
    return () => {
      connection.disconnect(); // "general" 방에서 연결 해제
    };
    // ...
```

그러면 리액트는 이 렌더링 중에 우리가 제공한 effect를 실행한다.

이번에는 `roomId` 가 `“travel”` 이므로 `“travel”` 채팅방과 동기화되기 시작한다.

```jsx
function ChatRoom({ roomId /* "travel" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // "travel" 방에 연결
    connection.connect();
    // ...
```

이제 사용자가 UI에서 선택한 방과 동일한 방에 연결된다.

컴포넌트가 다른 `roomId` 로 다시 렌더링할 때마다 effect가 다시 동기화된다.

## effect의 관점에서 생각하기

`Chatroom` 컴포넌트의 관점에서 일어난 모든 일을 요약해 보겠다.

1. `roomId`가 `"general"`으로 설정되어 마운트된 `ChatRoom`
2. `roomId`가 `"travel"`으로 설정되어 업데이트된 `ChatRoom`
3. `roomId`가 `"music"`으로 설정되어 업데이트된 `ChatRoom`
4. 마운트 해제된 `ChatRoom`

컴포넌트 생명주기에서 이러한 각 시점에서 effect는 다른 작업을 수행했다.

1. effect가 `"general"` 대화방에 연결됨
2. `"general"` 방에서 연결이 끊어지고 `"travel"` 방에 연결된 effect
3. `"travel"` 방에서 연결이 끊어지고 `"music"` 방에 연결된 effect
4. `"music"` 방에서 연결이 끊어진 effect

이제 effect 자체의 관점에서 무슨 일이 일어났는지 생각해 보자

```jsx
  useEffect(() => {
    // roomId로 지정된 방에 연결된 effect...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      // ...연결이 끊어질 때까지
      connection.disconnect();
    };
  }, [roomId]);
```

이 코드의 구조는 어떤 일이 일어났는지 겹치지 않는 시간의 연속으로 보는 데 영감을 줄 수 있다.

1. `"general"` 방에 연결된 effect (연결이 끊어질 때까지)
2. `"travel"` 방에 연결된 effect (연결이 끊어질 때까지)
3. `"music"` 방에 연결된 effect (연결이 끊어질 때까지)

이전에는 컴포넌트의 관점에서 생각했다. 컴포넌트의 관점에서 보면 effect를 “렌더링 후” 또는 “마운트 해제 전”과 같은 특정 시점에 실행되는 “콜백” 또는 “생명주기 이벤트”로 생각하기 쉬웠다.

이러한 사고방식은 매우 빠르게 복잡해지므로 피하는 것이 가장 좋다.

**대신 항상 한 번에 하나의 시작/중지 사이클에만 집중해라. 컴포넌트를 마운트, 업데이트 또는 마운트 해제하는 것은 중요하지 않다.**

**동기화를 시작하는 방법과 중지하는 방법만 확보하면 된다.**

**이 작업을 잘 수행하면 필요한 횟수만큼 effect를 시작하고 중지할 수 있는 탄력성을 확보할 수 있다.**

이렇게 하면 JSX를 생성하는 렌더링 로직을 작성할 때 컴포넌트가 마운트되는지 업데이트되는지 생각하지 않는 방법을 떠올릴 수 있다.

화면에 무엇이 표시되어야 하는지 설명하면 나머지는 리액트가 알아서 처리한다.

## 리액트가 effect를 다시 동기화될 수 있는지 확인하는 방법

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}

```

컴포넌트가 처음 마운트될 때 3개의 로그가 표시된다.

1. `✅ https://localhost:1234... 에서 "general" 방에 연결 중입니다.` *(개발 전용)*
2. `❌ https://localhost:1234에서 "일반" 방에서 연결 해제되었습니다.` *(개발 전용)*
3. `✅ https://localhost:1234... 에서 "general" 방에 연결 중입니다.`

처음 두 개의 로그는 개발 전용이다. 개발 시 리액트는 항상 각 컴포넌트를 한 번씩 다시 마운트한다.

**리액트는 개발 단계에서 즉시 강제로 동기화를 수행하여 effect가 다시 동기화할 수 있는지 확인한다.**

실제로 effect가 다시 동기화되는 주된 원인은 effect가 사용하는 일부 데이터가 변형된 경우이다.

위의 경우 sandbox에서 선택한 채팅방을 변경한다. `roomId` 가 변경되면 effect가 다시 동기화되는 것을 확인할 수 있다.

그러나 다시 동기화해야 하는 더 특이한 경우도 있다.

예를 들어, 채팅이 열려 있는 상태에서 위의 sandbox에서 `serverUrl` 을 편집해 봐라.

코드 편집에 대한 응답으로 effect는 다시 동기화된다.

## 리액트가 effect를 다시 동기화해야 한다는 것을 인식하는 방법

`roomId` 가 변경된 후 effect를 다시 동기화해야 한다는 것을 어떻게 리액트가 알았는지 궁금할 것이다.

그것은 우리가 종속성 목록에 `roomId` 를 포함함으로써 해당 코드가 `roomId` 에 종속되어 있다고 리액트에게 알렸기 때문이다.

```jsx
function ChatRoom({ roomId }) { // roomId prop은 시간이 지남에 따라 변경될 수 있습니다.
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // 이 effect는 roomId를 읽습니다.
    connection.connect();
    return () => {
      connection.disconnect();
    };

  }, [roomId]); // 따라서 React에 이 effect가 roomId에 "의존"한다고 알려줍니다.
  // ...
```

작동 방식은 다음과 같다.

1. `roomId`가 `prop`이므로 시간이 지남에 따라 변경될 수 있다는 것을 알고 있습니다.
2. effect가 `roomId`를 읽는다는 것을 알았습니다.(따라서 로직이 나중에 변경될 수 있는 값에 따라 달라집니다.)
3. 그렇기 때문에 `roomId`를 effect의 종속성으로 지정한 것입니다 (`roomId` 가 변경되면 다시 동기화되도록).

컴포넌트가 다시 렌더링될 때마다 리액트는 전달한 의존성 배열을 살펴본다.

배열의 값 중 하나라도 이전 렌더링 중에 전달한 동일한 지점의 값과 다르면 리액트는 effect를 다시 동기화한다.

## 각 effect는 별도의 동기화 프로세스를 나타낸다.

이 로직은 이미 작성한 effect와 동시에 실행되어야 해도 관련 없는 로직을 effect에 추가하지 마라.

예를 들어 사용자가 회의실을 방문할 때 분석 이벤트를 전송하고 싶다고 가정해 보자.

이미 `roomId` 에 의존하는 effect가 있으므로 거기에 분석 호출을 추가하고 싶을 수 있다.

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

하지만 나중에 이 effect에 연결을 다시 설정해야 하는 다른 종속성을 추가한다고 가정해 보자.

이 effect가 다시 동기화되면 의도하지 않은 동일한 방에 대해 `logVisit(roomId)` 도 호출한다.

방문을 기록하는 것은 연결과는 별개의 프로세스이다. 두 개의 개별 effect로 작성해라.

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
  }, [roomId]);

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // ...
  }, [roomId]);
  // ...
}
```

**코드의 각 effect는 별도의 독립적인 동기화 프로세스를 나타내야 한다.**

위의 예시에서는 한 effect를 삭제해도 다른 effect의 로직이 깨지지 않는다.

이는 서로 다른 것을 동기화하므로 분리하는 것이 합리적이라는 것을 나타낸다.

반면에 일관된 로직을 별도의 effect로 분리하면 코드가 “더 깔끔해” 보일 수 있지만 유지 보수가 어려워진다.

따라서 코드가 더 깔끔해 보이는지 여부가 아니라 프로세스가 동일하거나 분리되어 있는지를 고려해야 한다.

## 반응형 값에 “반응”하는 effect

effect에서 두 개의 변수(`serverUrl` 및 `roomId` )를 읽지만 종속성으로 `roomId` 만 지정했다.

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

`serverUrl` 이 종속성이 될 필요가 없는 이유는 무엇일까?

이는 재렌더링으로 인해 `serverUrl` 이 변경되지 않기 때문이다. 컴포넌트가 몇 번이나 다시 렌더링하든, 그 이유와 상관없이 항상 동일하다.

반면에 `roomId` 는 다시 렌더링할 때 달라질 수 있다. 컴포넌트 내부에서 선언된 **Props, state 및 기타값은 렌더링 중에 계산되고 리액트 데이터 흐름에 참여하기 때문에 반응형이다.**

## 빈 종속성이 있는 effect의 의미

`serverUrl`과 `roomId` 를 모두 컴포넌트 외부로 이동하면 어떻게 될까?

```jsx
const serverUrl = 'https://localhost:1234';
const roomId = 'general';

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ✅ 선언된 모든 종속성
  // ...
}
```

이제 effect의 코드는 어떤 반응형 값도 사용하지 않으므로 종속성이 비어 있을 수 있다.

컴포넌트의 관점에서 생각해보면, 빈 의존성 배열은 이 effect가 컴포넌트가 마운트될 때만 채팅방에 연결되고 컴포넌트가 마운트 해제될 때만 연결이 끊어진다는 것을 의미한다.

하지만 effect 관점에서 생각하면 마운트 및 마운트 해제에 대해 전혀 생각할 필요가 없다.

중요한 것은 effect가 동기화를 시작하고 중지하는 작업을 지정한 것이다. 

현재는 반응형 종속성이 없다. 하지만 사용자가 시간이 지남에 따라 `roomId` 또는 `serverUrl` 을 변경하려는 경우 effect 코드는 변경되지 않는다. 종속성에 추가하기만 하면 된다.

## 컴포넌트 본문에서 선언된 모든 변수는 반응형이다.

props와 state만 반응형 값인 것은 아니다. 이들로부터 계산하는 값도 반응형이다.

props나 state가 변경되면 컴포넌트는 다시 렌더링되고 그로부터 계산된 값도 변경된다. 이 때문에 effect에서 사용하는 컴포넌트 본문의 모든 변수는 effect 종속성 목록에 있어야 한다.

사용자가 드롭다운에서 채팅 서버를 선택할 수 있지만 설정에서 기본 서버를 구성할 수도 있다고 가정해 보자.

이미 setting state를 context에 넣어서 해당 context에서 `settings` 를 읽었다고 가정해 보겠다.

이제 props에서 선택한 서버와 기본 서버를 기준으로 `serverUrl` 을 계산한다.

```jsx
function ChatRoom({ roomId, selectedServerUrl }) { // roomId는 반응형입니다.
  const settings = useContext(SettingsContext); // settings는 반응형입니다.
  const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl는 반응형입니다.
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // effect는 roomId 와 serverUrl를 읽습니다.
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]); // 따라서 둘 중 하나가 변경되면 다시 동기화해야 합니다!
  // ...
}
```

이 예시에서 `serverUrl` 은 prop이나 state 변수가 아니다. 렌더링 중에 계산하는 일반 변수이다.

하지만 렌더링 중에 계산되므로 재렌더링으로 인해 변경될 수 있어 반응형이 된다.

**컴포넌트 내부의 모든 값은 반응형이다. 모든 반응형 값은 다시 렌더링할 때 변경될 수 있으므로 반응형 값을 effect의 종속 요소로 포함해야 한다.**

즉, effect는 컴포넌트 본문의 모든 값에 “반응”한다.

### 전역 또는 변경할 수 있는 값이 종속성이 될 수 있나요?

변경할 수 있는 값(전역 변수 포함)은 반응하지 않는다.

**`location.pathname` 과 같은 변경 가능한 값은 종속성이 될 수 없다.**

이 갓은 변경할 수 있으므로 리액트 렌더링 데이터 흐름 외부에서 언제든지 변경할 수 있다. 이 값을 변경해도 컴포넌트가 다시 렌더링되지는 않는다.

따라서 종속성에서 지정했더라도 리액트는 effect가 변경될 때 effect를 다시 동기화할지 알 수 없다.

또한 렌더링 도중(의존성을 계산할 때) 변경할 수 있는 데이터를 읽는 것은 렌더링의 순수성을 깨뜨리기 때문에 리액트의 규칙을 위반한다.

대신, `useSyncExternalStore` 를 사용하여 외부 변경할 수 없는 값을 읽고 구독해야 한다.

**`ref.current` 와 같이 변경 가능한 값이나 이 값에서 읽은 것 역시 종속성이 될 수 없다.**

`useRef` 가 반환하는 `ref` 객체 자체는 종속성이 될 수 있지만 `current` prop은 의도적으로 변경할 수 있다.

이를 통해 재렌더링을 트리거하지 않고도 무언가를 추적할 수 있다. 하지만 변경해도 다시 렌더링이 트리거되지 않기 때문에 반응형 값이 아니며, 리액트는 이 값이 변경될 때 effect를 다시 실행할지 알지 못한다.

## 리액트는 모든 반응형 값을 종속성으로 지정했는지 확인한다.

린터가 리액트에 대해 구성된 경우, effect의 코드에서 사용되는 모든 반응형 값이 종속성으로 선언되었는지 확인한다.

예를 들어, `roomId` 와 `serverUrl` 이 모두 반응형이기 때문에 이것은 린트 오류이다.

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) { // roomId는 반응형입니다.
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl는 반응형입니다.

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // <-- 여기 무언가 잘못되었습니다!

//...

```

이것은 리액트 오류처럼 보일 수 있지만 실제로는 코드의 버그를 지적하는 것이다.

`roomId` 와 `serverUrl` 은 시간이 지남에 따라 변경될 수 있지만, 변경 시 effect를 다시 동기화하는 것을 잊어버리고 있다.

사용자가 UI에서 다른 값을 선택한 후에도 초기 `roomId` 와 `serverUrl` 에 연결된 상태로 유지된다.

버그를 수정하려면 린터의 제안에 따라 effect의 종속 요소로 추가해야 한다.

```jsx
function ChatRoom({ roomId }) { // roomId는 반응형입니다.
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl는 반응형입니다.
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]); // ✅ 선언된 모든 종속성
  // ...
}
```

### 중요합니다!

어떤 경우에는 컴포넌트 내부에서 값이 선언되더라도 절대 변하지 않는다는 것을 리액트가 알고 있다.

예를 들어, `useState`에서 반환되는 `set` 함수와 `useRef` 에서 반환되는 ref 객체는 안정적이며, 다시 렌더링해도 변경되지 않도록 보장한다.

안정된 값은 반응하지 않으므로 목록에서 생략할 수 있다.

## 다시 동기화하지 않으려는 경우 어떻게 해야 하나요?

이전 예시에서는 `roomId` 와 `serverUrl` 을 종속성으로 나열하여 린트 오류를 수정했다.

**그러나 대신 이러한 값이 반응형이 아니라는 것, 즉 재렌더링의 결과로 변경될 수 없다는 것을 린터에 “증명”할 수 있다.**

예를 들어 `serverUrl` 과 `roomId` 가 렌더링에 의존하지 않고 항상 같은 값을 갖는다면 컴포넌트 외부로 옮길 수 있다. 이제 종속성이 될 필요가 없다.

```jsx
const serverUrl = 'https://localhost:1234'; // serverUrl는 반응형이 아닙니다.
const roomId = 'general'; // roomId는 반응형이 아닙니다.

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ✅ 선언된 모든 종속성
  // ...
}
```

effect 내부로 이동할 수도 있다. 렌더링 중에 계산되지 않으므로 반응하지 않는다.

```jsx
function ChatRoom() {
  useEffect(() => {
    const serverUrl = 'https://localhost:1234'; // serverUrl는 반응형이 아닙니다.
    const roomId = 'general'; // roomId는 반응형이 아닙니다.
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ✅ 선언된 모든 종속성
  // ...
}
```

**effect는 반응형 코드 블록이다.**

내부에서 읽은 값이 변경되면 다시 동기화된다. 상호작용당 한 번만 실행되는 이벤트 핸들러와 달리 effect는 동기화가 필요할 때마다 실행된다.

**종속성을 “선택”할 수 없다.**

종속성에는 effect에서 읽는 모든 반응형 값이 포함되어야 한다. 린터가 이를 강제한다.

때때로 이에 따라 무한 루프와 같은 문제가 발생하거나 effect가 너무 자주 다시 동기화될 수 있다.

린터를 억제하여 이러한 문제를 해결하지 마라. 대신 시도할 방법은 다음과 같다.

- **effect가 독립적인 동기화 프로세스를 나타내는지 확인해라.**
effect가 아무것도 동기화하지 않는다면 불필요한 것일 수 있다. 여러 개의 독립적인 것을 동기화하는 경우 분할해라.
- **props나 state에 “반응”하지 않고 effect를 다시 동기화하지 않고 최신 값을 읽으려면** effect를 반응하는 부분(effect에 유지할 것)과 반응하지 않는 부분(effect 이벤트라고 하는 것으로 추출할 수 있는 것)으로 분리하면 된다.
- **객체와 함수를 종속성으로 사용하지 마라.**
렌더링 중에 오브젝트와 함수를 생성한 다음 effect에서 읽으면 렌더링할 때마다 오브젝트와 함수가 달라진다. 그러면 매번 effect를 다시 동기화해야 한다.

### 주의하세요!

린터는 우리의 친구지만 그 힘은 제한되어 있다. 린터는 종속성이 잘못되었을 때만 알 수 있다.

각 사례를 해결하는 최선의 방법을 알지 못한다. 만약 린터가 종속성을 제안하지만 이를 추가하면 루프가 발생한다고 해서 린터를 무시해야 한다는 의미는 아니다.

해당 값이 반응적이지 않고 종속성이 될 필요가 없도록 effect 내부(또는 외부)의 코드를 변경해야 한다.

```jsx
useEffect(() => {
  // ...
  // 🔴 이런 식으로 린트를 억누르지 마세요.
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
```
