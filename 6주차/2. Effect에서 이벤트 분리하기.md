# Effect에서 이벤트 분리하기

이벤트 핸들러는 같은 상호작용을 반복하는 경우에만 재실행된다.

Effect는 이벤트 핸들러와 달리 prop이나 state 변수 등 읽은 값이 마지막 렌더링 때와 다르면 다시 동기화한다.

때로는 두 동작이 섞여서 어떤 값에는 반응해 재실행되지만, 다른 값에는 그러지 않는 Effect를 원할 때도 있다.

## 이벤트 핸들러와 Effect 중에 선택하기

먼저 이벤트 핸들러와 Effect의 차이점에 대해 간단하게 알아보자.

채팅방 컴포넌트를 구현한다고 생각했을 때 요구사항은 아래와 같다.

1. 채팅방 컴포넌트는 선택된 채팅방에 자동으로 연결해야 한다.
2. “전송”버튼을 누르면 채팅에 메세지를 전송해야 한다.

코드를 이미 구현했다고 했을 때, 그 코드를 어디에 넣어야 할지 확실하지 않다. 이벤트 핸들러와 Effect 중에 무엇을 해야 할까?

해당 코드가 실행되어야 하는 이유를 고려해 봐라.

### 이벤트 핸들러는 특정 상호작용에 대한 응답으로 실행된다.

사용자 관점에서 메세지는 “전송” 버튼이 클릭되었기 때문에 전송되어야 한다. 그러므로 메세지를 전송하는 건 이벤트 핸들러가 되어야 한다.

이벤트 핸들러는 특정 상호작용을 처리하게 해준다.

```jsx
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');
  // ...
  function handleSendClick() {
    sendMessage(message);
  }
  // ...
  return (
    <>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>전송</button>
    </>
  );
}
```

이벤트 핸들러를 사용하면 사용자가 버튼을 누를 때만 `sendMessage(message)` 가 실행될 것이라고 확신할 수 있다.

### Effect는 동기화가 필요할 때마다 실행된다.

채팅방 컴포넌트는 채팅방 연결을 유지해야 한다는 요구사항이 있다.

이 코드를 실행하는 이유는 특정 상호작용이 아니다. 사용자가 현재 채팅방 화면을 보고 상호작용할 수 있으므로 컴포넌트는 선택된 채팅 서버에 계속 연결되어 있어야 한다.

그러므로 이 코드는 Effect이다.

```jsx
function ChatRoom({ roomId }) {
  // ...
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

이렇게 코드를 작성하면 사용자가 수행하는 특정 상호작용에 상관없이 현재 선택된 채팅 서버와 항상 연결된 상태임을 확신할 수 있다.

## 반응형 값과 반응형 로직

이벤트 핸들러는 버튼 클릭과 같이 항상 “수동”으로 트리거 되지만, Effect는 동기화 유지에 필요한 만큼 자주 실행 및 재실행되기 때문에 “자동”으로 트리거된다고 직감적으로 말할 수 있다.

이에 대해 더 정확하게 생각하는 방법이 있다.

컴포넌트 본문 내부에 선언된 props, state, 변수를 `반응형 값` 이라고 한다. 이 예시에서 `serverUrl` 은 반응형 값이 아니지만 `roomId` 와 `message` 는 반응형 값이다.

반응형 값은 데이터 렌더링 과정에 관여한다.

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // ...
}
```

이벤트 핸들러와 Effect는 변화에 다르게 반응한다.

- **이벤트 핸들러 내부의 로직은 반응형이 아니다.**
사용자가 같은 상호작용을 반복하지 않는 한 재실행되지 않는다. 이벤트 핸들러는 변화에 “반응”하지 않으면서 반응형 값을 읽을 수 있다.
- **Effect 내부의 로직은 반응형이다.**
Effect에서 반응형 값을 읽는 경우 그 값을 의존성으로 지정해야 한다.
그렇게 하면 리렌더링이 그 값을 바꾸는 경우 리액트가 새로운 값으로 Effect 로젝을 다시 실행한다.

## Effect에서 비반응형 로직 추출하기

반응형 로직과 비반응형 로직을 섞으려 한다면 더 까다로워진다.

예를 들어 사용자가 채팅에 연결할 때 알림을 보여주는 상황을 상상해 봐라. 올바른 색상의 알림을 보여주기 위해 props로부터 현재 테마(dark 또는 light)를 읽는다.

```jsx
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('연결됨!', theme);
    });
    connection.connect();
    // ...
```

그러나 `theme` 는 (리렌더링으로 변경될 수 있는) 반응형 값이고 Effect가 읽는 모든 반응형 값은 의존성으로 선언되어야 한다.

그러므로 `theme` 을 Effect의 의존성으로 지정해야 한다.

```jsx
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('연결됨!', theme);
    });
    connection.connect();
    return () => {
      connection.disconnect()
    };
  }, [roomId, theme]); // ✅ 모든 의존성 선언됨
  // ...
```

하지만 `theme` 가 의존성이 되면서 값이 바뀔 때마다 채팅 연결이 다시 이뤄지는 문제가 생긴다.

다시 말해 아래의 코드 라인이 비록 Effect 내부에 있지만 반응형이 아니길 바란다.

```jsx
      // ...
      showNotification('연결됨!', theme);
      // ...
```

### Effect 이벤트 선언하기

> **개발 중인 기술!**
이 단락에선 **아직 안정된 버전의 리액트로 출시되지 않은 실험적인 API**를 설명한다.
> 

이 비반응형 로직을 Effect에서 추출하려면 `useEffectEvent`라는 특수한 Hook을 사용해라.

```jsx
import { useEffect, useEffectEvent } from 'react';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('연결됨!', theme);
  });
  // ...
```

여기서 `onConnected` 를 Effect 이벤트라고 한다.

Effect 로직의 일부지만 이벤트 핸들러와 훨씬 비슷하게 동작한다. 내부의 로직은 반응형이 아니며 항상 props와 state의 최근 값을 **바라본다**.

이제 Effect 내부에서 Effect 이벤트인 `onConnected` 를 호출할 수 있다.

```jsx
function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('연결됨!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ 모든 의존성이 선언됨
  // ...
```

이렇게 되면 문제가 해결된다. 

Effect에서 더이상 사용하지 않으므로, Effect의 의존성 목록에서 `theme` 을 제거해야 한다.

**또한 Effect 이벤트는 반응형이 아니므로 의존성에서 제외되어야 한다.**

Effect 이벤트가 이벤트 핸들러와 아주 비슷하다고 생각할 수 있다. 

이벤트 핸들러는 사용자의 상호작용에 대한 응답으로 실행되는 반면에 Effect 이벤트는 Effect에서 직접 트리거 된다는 것이 주요한 차이점이다.

Effect 이벤트를 사용하면 Effect의 반응형과 반응형이어서는 안되는 코드 사이의 연결을 끊어줄 수 있다.

### Effect 이벤트로 최근 props와 state 읽기

> **개발 중인 기술!**
이 단락에선 **아직 안정된 버전의 리액트로 출시되지 않은 실험적인 API**를 설명한다.
> 

Effect 이벤트는 의존성 린터를 억제하고 싶었을 많은 패턴을 수정하게 한다.

예를 들어 페이지 방문을 기록하기 위한 Effect가 있다고 해보자.

```jsx
function Page() {
  useEffect(() => {
    logVisit();
  }, []);
  // ...
}
```

이후 사이트에 여러 경로가 추가되고 이제 `Page` 컴포넌트는 현재 경로가 긴 `url` 을 prop으로 받는다.

`logVisit` 에 `url` 을 전달하여 호출하려는데 의존성 린터가 불평한다.

```jsx
function Page({ url }) {
  useEffect(() => {
    logVisit(url);
  }, []); // 🔴 React Hook useEffect has a missing dependency: 'url'
  // ...
}
```

이 코드로 무엇을 하려는 것인지 생각해 봐라.

각 URL은 서로 다른 페이지를 나타내므로 각 URL에 대한 방문을 따로 기록하려고 한다.

즉 이 `logVisit` 호출은 `url` 에 반응형이어야 한다. 그러므로 이런 경우에는 의존성 린터의 말을 따라 `url` 을 의존성으로 추가하는 것이 합리적이다.

```jsx
function Page({ url }) {
  useEffect(() => {
    logVisit(url);
  }, [url]); // ✅ 모든 의존성이 선언됨
  // ...
}
```

이제 모든 페이지 방문 기록에 장바구니의 물건 개수도 포함하려 한다고 해보겠다.

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  useEffect(() => {
    logVisit(url, numberOfItems);
  }, [url]); // 🔴 React Hook useEffect has a missing dependency: 'numberOfItems'
  // ...
}
```

Effect 내부에서 `numberOfItems` 를 사용했으므로 린터는 이를 의존성에 추가해달라고 한다.

하지만 `logVisit` 호출이 `numberOfItems` 에 반응하지 않길 원한다.

즉 페이지 방문은 어떤 의미에서 “이벤트”이다. 이 이벤트는 특정한 시점에 발생한다.

코드를 두 부분으로 나누자.

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    onVisit(url);
  }, [url]); // ✅ 모든 의존성 선언됨
  // ...
}
```

여기서 `onVisit` 은 Effect 이벤트이다. 그 내부의 코드는 반응형이 아니다.

그러므로 `numberOfItems` 의 변경이 주변 코드를 재실행시킬 걱정 없이 사용할 수 있다.

반면에 Effect 자체는 여전히 반응형이다. Effect 내부의 코드는 prop인 `url` 을 사용하므로 다른 `url` 로 리렌더링될 때마다 Effect가 재실행된다.

그로 인해 Effect 이벤트인 `onVisit` 이 호출될 것이다.

결과적으로 prop인 `url` 이 변경될 때마다 `logVisit` 을 호출할 것이고 항상 최근의 `numberOfItems` 를 읽을 것이다.

하지만 `numberOfItems` 혼자만 변경되면 어떠한 코드도 재실행되지 않는다.

### 중요합니다!

인수 없이 `onVisit()` 을 호출하고 그 내부에서 `url`을 읽을 수 있는지 궁금할 수도 있다.

```jsx
   const onVisit = useEffectEvent(() => {
    logVisit(url, numberOfItems);
  });

  useEffect(() => {
    onVisit();
  }, [url]);
```

이렇게 해도 읽을 수 있지만 `url` 을 Effect 이벤트에 명시적으로 전달하는 것이 좋다.

**`url` 을 Effect 함수에 인수로 전달함으로써 다른 `url` 로 페이지를 방문하는 것이 사용자 관점에서는 별도의 “이벤트”임을 나타내는 것이다.**

`visitedUrl` 은 발생한 “이벤트”의 일부분이다.

```jsx
  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    onVisit(url);
  }, [url]);
```

Effect 이벤트가 `visitedUrl` 을 명시적으로 “요구”하므로 `url` 을 Effect의 의존성에서 실수로 제거하는 일은 이제 있을 수 없다.

의존성에서 `url` 을 제거하면(별개의 페이지 방문을 하나로 취급하게 되는데) 린터가 경고할 것이다.

`onVisit` 이 `url` 에 반응하기를 원하므로 `url` 을 (반응형이 아닌) `onVisit` 내부에서 읽지 말고 Effect에서 전달해 준다.

이것은 Effect 내부에 비동기 로직이 있는 경우에 특히 중요해진다.

```jsx
  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    setTimeout(() => {
      onVisit(url);
    }, 5000); // 방문 기록을 지연시킴
  }, [url]);
```

여기서 `onVisit` 내부의 `url` 은 최근의 `url` 에 해당하지만 `visitedUrl` 은 최초의 이 Effect(및 `onVisit` 호출)을 실행하게 만든 `url` 에 해당한다.

### 대안으로 의존성 린터를 억제하는 것은 괜찮은가요?

기존 코드베이스에서는 아래와 같이 린트 규칙이 억제된 것을 가끔 볼 수 있다.

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  useEffect(() => {
    logVisit(url, numberOfItems);
    // 🔴 이런 식으로 린터를 억제하는 것은 피하세요.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [url]);
  // ...
}
```

`useEffectEvent` 가 리액트의 안정적인 기능이 되려면 **린터를 절대로 억제하지 않을 것**을 추천한다.

규칙을 억제하는 것의 첫 번째 단점은 코드에 추가한 새로운 반응형 의존성에 Effect가 “반응”해야 할 때 리액트가 더 이상 경고하지 않는다는 것이다.

이전 예시는 리액트가 의존성에 대해 `url` 을 추가하라고 상기시켜 주었기 때문에 그렇게 한 것이다.

린터를 억제하면 해당 Effect에 대한 향후 편집에 대해 이러한 알림을 더 이상 받지 않게 되고, 이는 버그로 이어진다.

다음은 린터를 억제하여 발생하는 혼란스러운 버그의 예시이다.

이 예시에서 `handleMove` 함수는 점이 커서를 따라가는지를 결정하기 위해 state 변수 `canMove` 의 현재 값을 읽어야 한다.

그러나 `handleMove` 내부에서 `canMove` 는 항상 `true` 이다.

```jsx
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        점 움직이게 하기
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}

```

이 코드의 문제는 린터를 억제한다는 것이다.

억제하는 것을 제거하면 이 Effect가 `handleMove` 함수에 의존해야 함을 알게될 것이다.

`handleMove` 는 컴포넌트 본문 내부에서 선언되어서 반응형 값이기 때문이다. 모든 반응형 값은 의존성으로 지정되어야 하며 그렇지 않으면 시간이 지남에 따라 오래되어 최근 값과 달라질 가능성이 있다.

기존 코드 작성자는 Effect가 반응형 값에 의존하지 않는다고(`[]`) 리액트에 “거짓말”을 했다.

그러므로 리액트는 `canMove` 가 (`handleMove` 와 함께) 변경된 후에 Effect를 다시 동기화하지 않았다.

리액트가 Effect를 다시 동기화하지 않았기 때문에 리스너로 부착된 `HandleMove` 는 초기 렌더링 과정에서 생성된 `handleMove` 함수이다.

초기 렌더링 과정에서 `canMove` 가 `true` 였으므로 초기 렌더링 과정에서 생성된 `handleMove` 는 영원히 `true` 를 보게 된다.

**린터를 억제하지 않으면 오래된 값으로 인한 문제가 절대 발생하지 않는다.**

`useEffectEvent` 를 사용하면 린터에 “거짓말”을 할 필요가 없으며 코드는 기대한 대로 동작한다.

```jsx
  const onMove = useEffectEvent(e => {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  });

  useEffect(() => {
    window.addEventListener('pointermove', onMove);

```

`useEffectEvent` 가 항상 올바른 해결책이라는 의미는 아니다.

`useEffectEvent` 는 반응형이 아니길 원하는 코드 라인에만 적용해야 한다. 위의 샌드박스에서는 Effect의 코드가 `canMove` 에 반응하길 원하지 않았다. 그러므로 Effect 이벤트로 추출하는 것이 합리적이었다.

### Effect 이벤트의 한계

> **개발 중인 기술!**
이 단락에선 **아직 안정된 버전의 리액트로 출시되지 않은 실험적인 API**를 설명한다.
> 

Effect 이벤트는 사용할 수 있는 방법이 매우 제한적이다.

- Effect 내부에서만 호출해라.
- 절대로 다른 컴포넌트나 Hook에 전달하지 마라.

예를 들어 아래와 같이 Effect 이벤트를 선언하고 전달하지 마라.

```jsx
function Timer() {
  const [count, setCount] = useState(0);

  const onTick = useEffectEvent(() => {
    setCount(count + 1);
  });

  useTimer(onTick, 1000); // 🔴 금지: Effect 이벤트 전달하기

  return <h1>{count}</h1>
}

function useTimer(callback, delay) {
  useEffect(() => {
    const id = setInterval(() => {
      callback();
    }, delay);
    return () => {
      clearInterval(id);
    };
  }, [delay, callback]); // 의존성에 "callback"을 지정해야 함
}
```

그 대신 Effect 이벤트는 항상 자신을 사용하는 Effect의 바로 근처에 선언해라.

```jsx
function Timer() {
  const [count, setCount] = useState(0);
  useTimer(() => {
    setCount(count + 1);
  }, 1000);
  return <h1>{count}</h1>
}

function useTimer(callback, delay) {
  const onTick = useEffectEvent(() => {
    callback();
  });

  useEffect(() => {
    const id = setInterval(() => {
      onTick(); // ✅ 바람직함: Effect 내부에서 지역적으로만 호출됨
    }, delay);
    return () => {
      clearInterval(id);
    };
  }, [delay]); // "onTick"(Effect 이벤트)를 의존성으로 지정할 필요 없음
}
```

Effect 이벤트는 Effect의 코드 중 비반응형인 “부분”이다.

Effect 이벤트는 자신을 사용하는 Effect 근처에 있어야 한다.
