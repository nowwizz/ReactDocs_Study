# useContext

`useContext` 는 컴포넌트에서 Context를 읽고 구독할 수 있는 리액트 Hook이다.

```jsx
const value = useContext(SomeContext)
```

---

## 레퍼런스

### `useContext(SomeContext)`

`useContext` 를 컴포넌트의 최상위 수준에서 호출하여 Context를 읽고 구독한다.

```jsx
import { useContext } from 'react';

function MyComponent() {
  const theme = useContext(ThemeContext);
  // ...
```

### 매개변수

- `someContext` : `createContext` 로 생성한 context이다. Context 자체는 정보를 담고 있지 않으며, 컴포넌트에서 제공하거나 읽을 수 있는 정보의 종류를 나타낸다.

### 반환값

`useContext` 는 호출하는 컴포넌트에 대한 Context 값을 반환한다. 이 값은 트리에서 호출하는 컴포넌트 상위의 가장 가까운 `SomeContext` 에 전달된 값으로 결정된다.

Provider가 없으면 반환된 값은 해당 Context에 대해 `createContext` 에 전달한 `defaultValue` 가 된다. 반환된 값은 항상 최신 상태이다.

Context가 변경되면 리액트는 자동으로 해당 Context를 읽는 컴포넌트를 다시 렌더링한다.

### 주의사항

- 컴포넌트 내의 `useContext()` 호출은 동일한 컴포넌트에서 반환된 Provider에 영향을 받지 않는다. 해당하는 `<Context>` 는 `useContext()` 호출을 하는 컴포넌트 상위에 배치되어야 한다.
- 리액트는 다른 `value` 를 받는 Provider로부터 시작해서 특정 Context를 사용하는 모든 자식들을 **자동으로 리렌더링**한다. 이전 값과 다음 값은 `Object.is` 를 통해 비교한다. `memo` 로 리렌더링을 건너뛰어도 자식들이 새로운 Context 값을 받는 것을 막지는 못한다.
- 빌드 시스템이 결과물에 중복 모듈을 생성하는 경우(심볼릭 링크에서 발생할 수 있음) Context가 손상될 수 있다. Context를 통해 무언가를 전달하는 것은 `===` 비교에 의해 결정되는 것처럼 Context를 제공하는 데 사용하는 `SomeContext` 와 Context를 읽는 데 사용하는 `SomeContext` 가 정확하게 동일한 객체인 경우에만 작동한다.

---

## 사용법

### 트리의 깊은 곳에 데이터 전달하기

컴포넌트의 최상위 수준에서 `useContext` 를 호출하여 Context를 읽고 구독한다.

```jsx
import { useContext } from 'react';

function Button() {
  const theme = useContext(ThemeContext);
  // ...
```

`useContext` 는 전달한 `Context` 에 대한 `Context Value` 를 반환한다. Context 값을 결정하기 위해 리액트는 컴포넌트 트리를 탐색하고 특정 Context에 대해 **상위에서 가장 가까운 Context Provider**를 찾는다.

Context를 `Button` 에 전달하려면 해당 버튼 또는 상위 컴포넌트 중 하나를 해당 Context Provider로 감싼다.

```jsx
function MyPage() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  );
}

function Form() {
  // ... 내부에서 버튼을 렌더링합니다. ...
}
```

Provider와 `Button` 사이에 얼마나 많은 컴포넌트 레이어가 있는지는 중요하지 않다.

`Form` 내부의 `Button` 이 어디에서나 `useContext(ThemeContext)` 를 호출하면, `“dark”` 를 값으로 받는다.

### 주의하세요!

`useContext()` 는 항상 호출하는 컴포넌트 상위에서 가장 가까운 Provider를 찾는다.

위쪽 방향으로 찾고 `useContext()` 를 호출하는 컴포넌트 안의 Provider는 고려하지 않는다.

---

## Context를 통해 전달된 데이터 업데이트하기

때때로 Context가 시간이 지남에 따라 변경되길 원할 것이다. 

Context를 업데이트 하려면 State와 결합해라. 부모 컴포넌트에서 State변수를 선언하고 현재 State를 `Context Value` 로 Provider에 전달한다.

```jsx
function MyPage() {
  const [theme, setTheme] = useState('dark');
  return (
    <ThemeContext value={theme}>
      <Form />
      <Button onClick={() => {
        setTheme('light');
      }}>
        Switch to light theme
      </Button>
    </ThemeContext>
  );
}
```

이제 Provider 내부의 모든 `Button` 은 현재 `theme` 값을 받게 된다.

Provider에 전달된 `theme` 값을 업데이트하기 위해 `setTheme` 을 호출하면, 모든 `Button` 컴포넌트가 새로운 `‘lignt’` 값으로 다시 렌더링된다.

---

## Fallback 기본값 지정

리액트가 부모 트리에서 특정 `Context` Provider를 찾을 수 없는 경우, `useContext()` 가 반환하는 Context 값은 해당 Context를 생성할 때 지정한 기본값과 동일하다.

```jsx
const ThemeContext = createContext(null);
```

기본값은 **변경되지 않는다.** Context를 업데이트하려면 state와 함께 써야 한다.

예를 들어 `null` 대신에 기본값으로 사용할 수 있는 더 의미 있는 값이 있는 경우가 많다.

```jsx
const ThemeContext = createContext('light');
```

이렇게 하면 실수로 해당 Provider없이 일부 컴포넌트를 렌더링해도 깨지지 않는다. 또한 테스트 환경에서 많은 Provider를 설정하지 않고도 컴포넌트가 테스트 환경에서 잘 작동하는 데 도움이 된다.

---

## 트리의 일부 Context 오버라이딩 하기

트리의 일부분을 다른 값의 Provider로 감싸서 해당 부분에 대한 Context를 오버라이딩할 수 있다.

```jsx
<ThemeContext value="dark">
  ...
  <ThemeContext value="light">
    <Footer />
  </ThemeContext>
  ...
</ThemeContext>
```

필요한 만큼 Provider를 중첩하고 오버라이딩할 수 있다.

---

## 객체와 함수를 전달할 때 리렌더링 최적화하기

Context를 통해 객체와 함수를 포함한 모든 값을 전달할 수 있다.

```jsx
function MyApp() {
  const [currentUser, setCurrentUser] = useState(null);

  function login(response) {
    storeCredentials(response.credentials);
    setCurrentUser(response.user);
  }

  return (
    <AuthContext value={{ currentUser, login }}>
      <Page />
    </AuthContext>
  );
}
```

여기서 `Context Value` 는 두 개의 프로퍼티를 가진 자바스크립트 객체이며, 그 중 하나는 함수이다.

`MyApp` 이 다시 렌더링할 때마다(예를 들어 경로 업데이트 시) 다른 함수를 가리키는 다른 객체가 될 것이므로 리액트는 `useContext(AuthContext)` 를 호출하는 트리 깊숙한 곳에 있는 모든 컴포넌트도 다시 렌더링해야 한다.

작은 앱에서는 문제가 없지만, `currentUser` 와 같은 기본적인 데이터가 변경되지 않았다면 다시 렌더링할 필요가 없다.

리액트가 이 사실을 활용할 수 있도록 `login` 함수를 `useCallback` 으로 감싸고 객체 생성을 `useMemo` 로 감싸면 된다.

이것이 성능 최적화이다.

```jsx
import { useCallback, useMemo } from 'react';

function MyApp() {
  const [currentUser, setCurrentUser] = useState(null);

  const login = useCallback((response) => {
    storeCredentials(response.credentials);
    setCurrentUser(response.user);
  }, []);

  const contextValue = useMemo(() => ({
    currentUser,
    login
  }), [currentUser, login]);

  return (
    <AuthContext value={contextValue}>
      <Page />
    </AuthContext>
  );
}
```

이 변경으로 인해 `MyApp` 이 다시 렌더링해야 하는 경우에도 `currentUser` 가 변경되지 않는 한 `userContext(AuthContext)` 를 호출하는 컴포넌트는 다시 렌더링할 필요가 없다.

---

## 문제해결

### 컴포넌트가 Provider에서 값을 인식하지 못하고 있다.

이런 일이 발생하는 몇 가지 이유가 있다.

1. `useContext()` 를 호출하는 컴포넌트와 동일한 컴포넌트에서 `<SomeContext>` 를 렌더링하는 경우, `<SomeContext>` 를 `useContext()` 를 호출하는 컴포넌트의 위와 바깥으로 이동해라.
2. 컴포넌트를 `<SomeContext>` 로 감싸는 것을 잊었거나 생각했던 것과 다른 트리의 다른 부분에 배치했을 수 있다. 리액트 개발자 도구를 사용하여 계층 구조가 올바른지 확인해라
3. 사용 중인 도구에서 발생하는 빌드 문제로 인해, 제공하는 컴포넌트에서의 `someContext` 와 값을 읽는 컴포넌트에서의 `someContext` 가 서로 다른 객체로 처리되는 문제가 발생할 수 있다.
예를 들어 심볼릭 링크를 사용하는 경우 발생할 수 있다. 이를 확인하려면 `window.someContext1` 과 `window.SomeContext2` 를 전역에 할당하고 콘솔에서 `window.SomeContext1 === window.SomeContext2` 인지 확인하면 된다. 동일하지 않은 경우 빌드 도구 수준에서 해당 문제를 수정해라.

### 기본값이 다른데도 Context가 `undefined` 를 반환한다.

트리에 `value` 가 없는 Provider가 있을 수 있다.

```jsx
// 🚩 Doesn't work: no value prop
<ThemeContext>
   <Button />
</ThemeContext>
```

`value` 를 지정하는 것을 잊어버린 경우, `value={undefined}` 를 전달하는 것과 같다.

실수로 다른 Prop의 이름을 사용했을 수도 있다.

```jsx
// 🚩 Doesn't work: prop should be called "value"
<ThemeContext theme={theme}>
   <Button />
</ThemeContext>
```

두 가지 경우 모두 콘솔에 리액트에서 경고가 표시될 것이다. 이를 수정하려면 Prop `value`를 호출해라.

```jsx
 // ✅ Passing the value prop
<ThemeContext value={theme}>
   <Button />
</ThemeContext>
```

`createContext(defaultValue)` 호출의 기본값은 **위에 일치하는 Provider가 전혀 없는 경우**에만 사용된다는 점에 유의해라.

부모 트리 어딘가에 `<SomeContext value={undefined}>` 컴포넌트가 있는 경우, `useContext(SomeContext)` 를 호출하는 컴포넌트는 `undefined` 를 Context 값으로 받는다.
