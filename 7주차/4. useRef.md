# useRef

`useRef` 는 렌더링에 필요하지 않은 값을 참조할 수 있는 React Hook이다.

```jsx
const ref = useRef(initialValue)
```

---

## 레퍼런스

### `useRef(initialValue)`

컴포넌트의 최상위 레벨에서 `useRef` 를 호출하여 ref를 선언한다.

```jsx
import { useRef } from 'react';

function MyComponent() {
  const intervalRef = useRef(0);
  const inputRef = useRef(null);
  // ...
```

### 매개변수

- `initialValue` : ref 객체의 `current` 프로퍼티 초기 설정값이다. 여기에는 어떤 유형의 값이든 지정할 수 있다. 이 인자는 초기 렌더링 이후부터는 무시된다.

### 반환값

`useRef` 는 단일 프로퍼티를 가진 객체를 반환한다:

- `current` : 처음에는 전달한 `initialValue` 로 설정된다. 나중에 다른 값으로 바꿀 수 있다. ref 객체를 JSX 노드의 `ref` 어트리뷰트로 리액트에 전달하면 리액트는 `current` 프로퍼티를 설정한다.

다음 렌더링에서 `useRef` 는 동일한 객체를 반환한다.

### 주의 사항

- `ref.current` 프로퍼티는 state와 달리 변이할 수 있다. 그러나 렌더링에 사용되는 객체를 포함하는 경우 해당 객체를 변이해서는 안된다.
- `ref.current` 프로퍼티를 변경해도 리액트는 컴포넌트를 다시 렌더링하지 않는다. ref는 일반 JavaScript 객체이기 때문에 리액트는 사용자가 언제 변경했는지 알지 못한다.
- 초기화를 제외하고는 렌더링 중에 `ref.current` 를 쓰거나 읽지 마라. 이렇게 하면 컴포넌트의 동작을 예측할 수 없게 된다.
- Strict Mode에서 리액트는 컴포넌트 함수를 두 번 호출하여 의도하지 않은 변경을 찾을 수 있도록 돕는다. 이는 개발 환경 전용 동작이며 Production 환경에는 영향을 미치지 않는다. 각 ref 객체는 두 번 생성되고 그중 하나는 버려진다. 컴포넌트 함수가 순수하다면, 컴포넌트의 로직에 영향을 미치지 않는다.

---

## 사용법

### ref로 값 참조하기

컴포넌트의 최상위 레벨에서 `useRef` 를 호출하여 하나 이상의 ref를 선언한다.

```jsx
import { useRef } from 'react';

function Stopwatch() {
  const intervalRef = useRef(0);
  // ...
```

`useRef` 는 처음에 제공한 `초기값` 으로 설정된 단일 `current 프로퍼티` 가 있는 `ref 객체` 를 반환한다.

다음 렌더링에서 `useRef` 는 동일한 객체를 반환한다. 정보를 저장하고 나중에 읽을 수 있도록 `current` 속성을 변경할 수 있다. state가 떠오를 수 있지만, 둘 사이에는 중요한 차이점이 있다.

**ref를 변경해도 리렌더링을 촉발하지 않는다.**

즉 ref는 컴포넌트의 시각적 출력에 영향을 미치지 않는 정보를 저장하는 데 적합하다. 예를 들어 interval ID를 저장했다가 나중에 불러와야 하는 경우 ref를 넣을 수 있다. 

ref 내부의 값을 업데이트하려면 `current 프로퍼티` 를 수동으로 변경해야 한다:

```jsx
function handleStartClick() {
  const intervalId = setInterval(() => {
    // ...
  }, 1000);
  intervalRef.current = intervalId;
}
```

나중에 ref에서 해당 interval ID를 읽어 해당 interval을 취소할 수 있다.

```jsx
function handleStopClick() {
  const intervalId = intervalRef.current;
  clearInterval(intervalId);
}
```

ref를 사용하면 다음을 보장한다:

1. (렌더링할 때마다 재설정되는 일반 변수와 달리) 리렌더링 사이에 **정보를 저장**할 수 있다.
2. (리렌더링을 촉발하는 state 변수와 달리) 변경해도 **리렌더링을 촉발하지 않는다.**
3. (정보가 공유되는 외부 변수와 달리) 각각의 컴포넌트에 **로컬로 저장된다.**

ref로 변경해도 다시 렌더링되지 않으므로 화면에 표시되는 정보를 저장하는 데는 ref가 적합하지 않다.

→ 이럴 땐 state 사용

### 주의하세요!

**렌더링 중에는 `ref.current` 를 쓰거나 읽지 마라.**

리액트는 컴포넌트의 본문이 순수 함수처럼 동작하기를 기대한다:

- 입력값들(props, state, context)이 동일하면 완전히 동일한 JSX를 반환해야 한다.
- 다른 순서나 다른 인수를 사용하여 호출해도 다른 호출의 결과에 영향을 미치지 않아야 한다.

**렌더링 중에** ref를 읽거나 쓰면 이러한 기대가 깨진다.

```jsx
function MyComponent() {
  // ...
  // 🚩 Don't write a ref during rendering
  myRef.current = 123;
  // ...
  // 🚩 Don't read a ref during rendering
  return <h1>{myOtherRef.current}</h1>;
}
```

**대신 이벤트 핸들러나 Effect에서** ref를 읽거나 쓸 수 있다.

```jsx
function MyComponent() {
  // ...
  useEffect(() => {
    // ✅ You can read or write refs in effects
    myRef.current = 123;
  });
  // ...
  function handleClick() {
    // ✅ You can read or write refs in event handlers
    doSomething(myOtherRef.current);
  }
  // ...
}
```

렌더링 중에 무언가를 일거나 써야만 하는 경우, 대신 state를 사용해라.

컴포넌트는 이러한 규칙을 어기더라도 여전히 작동할 수도 있지만, 리액트에 추가되는 대부분의 새로운 기능들은 이러한 기대에 의존한다.

### ref로 DOM 조작하기

ref를 사용하여 DOM을 조작하는 것은 특히 일반적이다. 리액트에는 이를 위한 기본 지원이 있다.

먼저 `초기값` 이 `null` 인 `ref 객체` 를 선언해라:

```jsx
import { useRef } from 'react';

function MyComponent() {
  const inputRef = useRef(null);
  // ...
```

그런 다음 ref 객체를 `ref`  속성으로 조작하려는 DOM 노드의 JSX에 전달해라:

```jsx
  // ...
  return <input ref={inputRef} />;
```

리액트가 DOM 노드를 생성하고 화면을 그린 후, 리액트는 ref 객체의 `current 프로퍼티` 를 DOM 노드로 설정한다. 이제 DOM 노드 `<input>` 에 접근해 `focus()` 와 같은 메서드를 호출할 수 있다.

```jsx
  function handleClick() {
    inputRef.current.focus();
  }
```

노드가 화면에서 제거되면 리액트는 `current` 프로퍼티를 다시 `null`로 설정한다.

### ref 콘텐츠 재생성 피하기

리액트는 초기에 ref 값을 한 번 저장하고, 다음 렌더링부터는 이를 무시한다.

```jsx
function Video() {
  const playerRef = useRef(new VideoPlayer());
  // ...
```

`new VideoPlayer()` 의 결과는 초기 렌더링에만 사용되지만, 호출 자체는 이후의 모든 렌더링에서도 여전히 계속 이뤄진다.

이는 값비싼 객체를 생성하는 경우 낭비일 수 있다. 이 문제를 해결하려면 대신 다음과 같이 ref를 초기화할 수 있다:

```jsx
function Video() {
  const playerRef = useRef(null);
  if (playerRef.current === null) {
    playerRef.current = new VideoPlayer();
  }
  // ...
```

일반적으로 렌더링 중에 `ref.current` 를 쓰거나 읽는 것은 허용되지 않는다. 하지만 이 경우에는 결과가 항상 동일하고 초기화 중에만 조건이 실행되므로 충분히 예측할 수 있어서 괜찮다.

### `useRef` 를 초기화할 때 null 검사를 피하는 방법

타입 검사기를 사용하면서 항상 `null` 을 검사하고 싶지 않다면 다음과 같은 패턴을 대신 사용해 볼 수 있다:

```jsx
function Video() {
  const playerRef = useRef(null);

  function getPlayer() {
    if (playerRef.current !== null) {
      return playerRef.current;
    }
    const player = new VideoPlayer();
    playerRef.current = player;
    return player;
  }

  // ...
```

여기서 `playerRef` 자체는 nullable하다. 하지만 타입 검사기에 `getPlayer()` 가 `null` 을 반환하는 경우가 없다는 것을 확신시킬 수 있어야 한다.

그런 다음 이벤트 핸들러에서 `getPlayer()` 를 사용해라.

---

## 문제 해결

### 커스텀 컴포넌트에 대한 ref를 얻을 수 없다.

컴포넌트에 `ref` 를 전달하고자 다음과 같이 하면:

```jsx
const inputRef = useRef(null);

return <MyInput ref={inputRef} />;
```

다음과 같은 오류가 발생할 것이다.

`TypeError: Cannot read properties of null` 

기본적으로 컴포넌트는 내부의 DOM 노드에 대한 ref를 외부로 노출하지 않는다.

이 문제를 해결하려면  ref를 가져오고자 하는 컴포넌트를 찾아라:

```jsx
export default function MyInput({ value, onChange }) {
  return (
    <input
      value={value}
      onChange={onChange}
    />
  );
}
```

그리고 `ref` 를 컴포넌트가 받는 props 목록에 추가한 뒤, 아래처럼 해당 자식 내장 컴포넌트에 prop으로 `ref`를 전달해라.

```jsx
function MyInput({ value, onChange, ref }) {
  return (
    <input
      value={value}
      onChange={onChange}
      ref={ref}
    />
  );
};

export default MyInput;
```

그러면 부모 컴포넌트가 ref를 가져올 수 있다.
