# useEffect

`useEffect` 는 외부 시스템과 컴포넌트를 동기화하는 리액트 Hook이다.

```jsx
useEffect(setup, dependencies?)
```

---

## 레퍼런스

### `useEffect(setup, defendencies?)`

컴포넌트의 최상위 레벨에서 `useEffect` 를 호출하여 Effect를 선언할 수 있다.

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]);
  // ...
}
```

### 매개변수

- `setup(설정)` : Effect의 로직이 포함된 함수이다. 설정 함수는 선택적으로 clean up 함수를 반환할 수 있다. 리액트는 컴포넌트가 DOM에 추가된 이후에 설정 함수를 실행한다. 의존성의 변화에 따라 컴포넌트가 리렌더링되었을 경우, (설정 함수에 정리 함수를 추가했었다면) 리액트는 이전 렌더링에 사용된 값으로 정리 함수를 실행한 후 새로운 값으로 설정 함수를 실행한다. 컴포넌트가 DOM에서 제거된 경우에도 정리 함수를 실행한다.
- `dependencies` **선택사항**: `설정` 함수의 코드 내부에서 참조되는 모든 반응형 값들이 포함된 배열로 구성된다. 반응형 값에는 props와 state, 모든 변수 및 컴포넌트 body에 직접적으로 선언된 함수들이 포함된다. 린터가 리액트 환경에 맞게 설정되어 있을 경우, 린터는 모든 반응형 값들이 의존성에 제대로 명시되어 있는지 검증할 것이다. 의존성 배열은 항상 일정한 수의 항목을 가지고 있어야 하며 `[dep1, dep2 ,dep3]` 과 같이 작성되어야 한다. 리액트는 각각의 의존성들을 `Object.is` 비교법을 통해 이전 값과 비교한다. 의존성을 생략할 경우, Effect는 컴포넌트가 리렌더링될 때마다 실행된다.

### 반환값

`useEffect`는 `undefined` 를 반환한다.

### 주의 사항

- `useEffect` 는 Hook이므로 컴포넌트의 최상위 또는 커스텀 훅에서만 호출할 수 있다. 반복문이나 조건문에서는 사용할 수 없다. 필요한 경우 새로운 컴포넌트를 추출하고 해당 컴포넌트로 state를 이동해서 사용할 수 있다.
- 외부 시스템과 컴포넌트를 동기화할 필요가 없는 경우, Effect를 선언할 필요가 없을 수 있다.
- Strict Mode에서 사용할 경우, 리액트는 실제 첫 번째 설정 함수가 실행되기 이전에 **개발 모드에만 한정하여 한 번의 추가적인 설정 + 정리 사이클을 실행한다.** 이는 정리 로직이 설정 로직을 완벽히 “반영”하고 설정 로직이 수행하는 작업을 중단하거나 취소할 수 있는지를 확인하는 스트레스 테스트이다. 이에 따라 문제가 생길 경우, 정리 함수를 구현해라.
- 만약 의존성이 객체이거나 컴포넌트 내부에 선언된 함수일 경우에는 Effect가 필요 이상으로 재실행될 수 있다. 이를 수정하려면 불필요한 객체 의존성이나 함수 의존성을 제거해라. 또는 state 업데이트를 추출하거나 Effect 밖으로 비반응형 로직을 빼 낼 수 있다.
- Effect가 사용자 상호작용(클릭 등)에 의해 발생하지 않았다면, 리액트는 일반적으로 **Effect를 실행하기 전에 브라우저가 업데이트된 화면을 먼저 렌더링하도록 한다.** 만약 Effect가 시각적인 작업을 수행하고, 이에 따라 지연이 눈에 띄게 나타난다면, `useEffect` 대신 `useLayoutEffect` 를 사용해라.
- Effect가 사용자 상호작용으로 인해 발생한 경우, **리액트는 화면이 업데이트되어 브라우저가 화면을 그리기 전에 Effect를 실행할 수 있다.** 이것이 Effect의 결과를 이벤트 시스템이 관찰할 수 있도록 보장한다. 이는 대개 예상대로 작동하지만, `alert()` 와 같이 작업을 브라우저가 화면을 그린 후로 미뤄야 하는 경우 `setTimeout` 을 활용할 수 있다.
- Effect가 사용자 상호작용에 의해 발생했더라도, **리액트는 때로 Effect 내부의 상태 업데이트를 처리하기 전에 브라우저가 화면을 다시 그리도록 허용할 수 있다.** 이는 대개 예상대로 작동하지만, 브라우저가 화면을 다시 그리지 않도록 막아야 하는 상황이라면 `useEffect` 대신 `useLayoutEffect` 를 사용해야 한다.
- Effect는 **client 환경에서만 동작한다.** 서버 렌더링에서는 동작하지 않는다.

---

## 사용방법

### 외부 시스템과 연결

몇몇 컴포넌트들은 페이지에 표시되는 동안 네트워크나 브라우저 API, 또는 서드파티 라이브러리와의 연결이 유지되어야 한다. 리액트에 제어되지 않는 이러한 시스템들을 외부 시스템이라 부른다.

컴포넌트를 외부 시스템과 연결하려면 컴포넌트 최상위 레벨에서 `useEffect` 를 호출해야 한다.

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]);
  // ...
}
```

`useEffect` 는 2개의 인수가 필요하다.

1. 외부 시스템과 컴포넌트를 연결하는 `설정 코드` 가 포함된 설정 함수
    1. 외부 시스템과의 연결을 해제하는 `정리 코드` 가 포함된 정리 함수를 반환할 수 있다.
2. 위 함수 내부에서 사용하는 컴포넌트에서 비롯된 반응형 값들을 포함하는 `의존성 배열` 

**리액트는 설정 함수와 정리 함수가 필요할 때마다 호출할 수 있으며, 이는 여러 번 호출될 수 있다.**

1. 컴포넌트가 화면에 추가되었을 때 `설정 코드` 가 동작한다(마운트 시).
2. `의존성` 이 변경된 컴포넌트가 리렌더링될 때마다 아래 동작을 수행한다.
    1. 먼저 `정리 코드` 기 오래된 props와 state와 함께 실행된다.
    2. 이후, `설정 코드` 가 새로운 props와 state와 함께 실행된다.
3. 컴포넌트가 화면에서 제거된 이후에 `정리 코드` 가 마지막으로 실행된다(마운트 해제 시).

### 커스텀 Hook을 Effect로 감싸기

Effect는 “탈출구”이다. “리액트 바깥으로 나가야 할 때”와 유즈케이스에 필요한 빌트인 솔루션이 없을 때 사용한다.

만약 Effect를 자주 작성해야 한다면 컴포넌트가 의존하고 있는 공통적인 동작들을 커스텀 Hook으로 추출해야 한다.

### 리액트로 작성되지 않은 위젯 제어하기

가끔은 컴포넌트의 prop 또는 state를 외부 시스템과 동기화해야 할 때가 있다.

예를 들어 리액트 없이 작성된 서드 파티 지도 위젯이나 비디오 플레이어 컴포넌트가 있다면 이 컴포넌트의 state를 현재 리액트 컴포넌트의 state와 일치하도록 하기 위해 Effect를 사용할 수 있다.

이 Effect는 `map-widget.js` 에 정의된 `MapWidget` 클래스의 인스턴스를 생성한다. `Map` 컴포넌트의 `zoomLevel` prop을 변경할 때, Effect는 해당 클래스 인스턴스의 `setZoom()` 을 호출하여 동기화를 유지한다.

```jsx
import { useRef, useEffect } from 'react';
import { MapWidget } from './map-widget.js';

export default function Map({ zoomLevel }) {
  const containerRef = useRef(null);
  const mapRef = useRef(null);

  useEffect(() => {
    if (mapRef.current === null) {
      mapRef.current = new MapWidget(containerRef.current);
    }

    const map = mapRef.current;
    map.setZoom(zoomLevel);
  }, [zoomLevel]);

  return (
    <div
      style={{ width: 200, height: 200 }}
      ref={containerRef}
    />
  );
}

```

이 예시에서는 정리 함수가 필요하지 않다. 이는 `MapWidget` 클래스가 클래스에 전달된 DOM 노드만 관리하기 때문이다.

`Map` 컴포넌트가 트리에서 제거된 후, 브라우저의 자바스크립트 엔진에 의해 DOM 노드와 `MapWidget` 클래스 인스턴스 모두가 자동으로 가비지 컬렉션에 의해 정리된다.

> **가비지 컬렉션이란?**
더 이상 사용하지 않는 메모리를 자동으로 해제하는 기능
> 

### Effect를 이용한 데이터 페칭

컴포넌트에 데이터를 페칭하기 위해 Effect를 사용할 수 있다. 만약 프레임워크를 사용하고 있다면 프레임워크의 데이터 페칭 메커니즘을 이용하는 것이 Effect를 직접 작성하는 것보다 더 효율적일 것이다.

만약 직접 Effect를 작성하여 데이터를 페칭하고 싶다면, 코드는 다음과 같을 수 있다.

```jsx
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);

  useEffect(() => {
    let ignore = false;
    setBio(null);
    //fetchBio같은 요청은 비동기 함수이기 때문에 요청을 보내고 백그라운드로 보낸 후 다음 코드를 실행함
    //응답이 오면 그에 따라 처리
    //따라서 요청 두 개가 동시에 백그라운드에서 응답을 기다리고 있을 수 있음
    fetchBio(person).then(result => {
      if (!ignore) {
        setBio(result);
      }
    });
    return () => {
      ignore = true;
    };
  }, [person]);

  // ...
```

`ignore` 변수의 초기값이 `false` 로 설정되고 정리 함수 동작 중에 `true` 로 설정되는 것에 주목해라.

이 로직은 코드가 “경쟁 상태”에 빠지지 않도록 보장해 준다. 네트워크 요청을 보낸 순서와 응답을 받는 순서가 다르게 동작할 수 있기 때문에 이러한 처리가 필요하다.

또한 `async` / `await` 구문을 사용하여 코드를 다시 작성할 수 있지만 여전히 정리 함수를 제공해야 함

```jsx
  useEffect(() => {
    async function startFetching() {
      setBio(null);
      const result = await fetchBio(person);
      if (!ignore) {
        setBio(result);
      }
    }

    let ignore = false;
    startFetching();
    return () => {
      ignore = true;
    }
  }, [person]);
```

Effect에서 직접 데이터 페칭 로직을 작성하면 나중에 캐싱 기능이나 서버 렌더링과 같은 최적화를 추가하기 어려워진다.

자체 제작된 커스텀 Hook이나 커뮤니티에 의해 유지보수되는 Hook을 사용하는 편이 더 간단하다.

### Effect에서 데이터를 페칭하는 좋은 대안은 무엇인가요?

Effect 내부에서 `fetch` 호출을 작성하는 것은 클라이언트 사이드 앱에서 데이터를 페칭하는 가장 인기 있는 방법이다. 하지만 이것은 매우 수동적인 방식이며 큰 단점이 있다.

- **Effect는 서버에서는 실행되지 않는다.**
이는 초기 서버 렌더링 된 HTML이 데이터가 없는 state만을 포함한다는 것을 의미한다. 클라이언트 컴퓨터는 모든 자바스크립트를 다운로드 받고 앱을 렌더링한 다음 데이터를 로드한다. 이는 효율적이지 않을 수 있다.
    - Effect로 fetch 사용 시, 서버 사이드 렌더링에서는 데이터가 없는 상태에서 HTML을 렌더링 완료 후 자바스크립트를 다운받음
    - Effect는 화면이 다 그려진 다음에 실행되는 훅이기 때문에 데이터도 없는데 HTML 렌더링하고~ Effect로 데이터 가져오고~ 화면 띄워야 함.. → 로딩이 길어지거나 깜빡임 발생
    - 이는 굉장히 비효율적인데 서버 사이드 렌더링의 장점 중 하나인 데이터를 가져와서 HTML을 서버에서 미리 렌더링해서 보여줌으로써 부드럽게 완성된 페이지를 보여줄 수 있다는 점을 아예 못 느낀다는 거임
- **Effect 내부에서 직접 페칭을 하는 것은 네트워크 폭포가 생성되기 쉽게 한다.**
부모 컴포넌트 렌더링 후 일부 데이터를 페칭하고 나서 자식 컴포넌트가 렌더링된다. 이후 자식 컴포넌트가 자신의 데이터를 페칭하기 시작한다. 네트워크의 속도가 빠르지 않다면 이 방법은 모든 데이터를 병렬로 페칭하는 것보다 훨씬 느리다.
- **Effect 내부에서 직접 데이터를 페칭하는 것은 일반적으로 데이터를 미리 로드하거나 캐싱하지 않는다는 것을 의미한다.**
예를 들어 컴포넌트가 마운트 해제되고 다시 마운트되었을 때 데이터를 다시 가져와야 한다.
- **사용하기 매우 불편한 방법이다.**
경쟁 조건과 같은 버그를 발생시키지 않도록 fetch 호출을 작성할 때 상당한 양의 보일러 플레이트 코드가 필요하다.
    - 보일러 플레이트 코드: 항상 똑같이 반복해서 써야 하는 코드

이러한 단점은 리액트만 해당되는 것이 아니다. 다른 라이브러리를 사용하여 데이터를 페칭할 때도 해당된다. 라우팅과 마찬가지로 데이터 페칭은 세부적인 사항이 많으므로 다음과 같은 접근 방식을 권장한다.

- **프레임워크를 사용하는 경우, 해당 프레임워크에 내장된 데이터 페칭 매커니즘을 활용해라.**
현대 리액트 프레임워크는 매우 효율적이며 위에서 언급한 문제점이 없는 통합된 데이터 페칭 기능을 가지고 있다.
- **그렇지 않은 경우, 클라이언트 측 캐시를 사용하거나 직접 개발을 고려해라.**
인기 있는 오픈소스 솔루션으로는 React Query, useSWR, 그리고 React Router 6.4+가 있다. 물론 직접 솔루션을 개발할수도 있으며 이 경우에는 이펙트를 내부적으로 사용하면서도 데이터 사전로드 또는 데이터 요구사항을 라우트로 호이스팅하는 방법을 통해 중복 요청 방지, 응답 캐싱 및 네트워크 폭포 효과 방지를 구현할 수 있다.

만약 이러한 접근 방식이 적합하지 않다면 Effect 내부에서 데이터를 페칭하는 것을 계속 사용할 수도 있다.

### 반응형 값 의존성 지정

**Effect의 의존성을 “선택”할 수 없다는 점에 유의해라.**

Effect 코드에서 사용하는 모든 `반응형 값` 은 의존성으로 선언되어야 한다. Effect의 의존성 배열은 코드에 의해 결정된다.

```jsx
function ChatRoom({ roomId }) { // 이것은 반응형 값입니다
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // 이것도 반응형 값입니다

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // 이 Effect는 이 반응형 값들을 읽습니다
    connection.connect();
    return () => connection.disconnect();
  }, [serverUrl, roomId]); // ✅ 그래서 이 값들을 Effect의 의존성으로 지정해야 합니다
  // ...
}
```

**의존성을 제거하려면 그것이 의존성이 되지 않아야 함을 린터에 증명해야 한다.**

`// eslint-ignore-next-line react-hooks/exhaustive-deps` 와 같은 코드로 린터를 억제하는 것보다 증명하는 것이 버그를 줄일 수 있다.

### Effect에서 이전 state를 기반으로 state 업데이트 하기

Effect에서 이전 state를 기반으로 state를 업데이트하려면 문제가 발생할 수 있다.

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(count + 1); // 초마다 카운터를 증가시키고 싶습니다...
    }, 1000)
    return () => clearInterval(intervalId);
  }, [count]); // 🚩 ... 하지만 'count'를 의존성으로 명시하면 항상 인터벌이 초기화됩니다.
  // ...
}
```

`count` 가 반응형 값이므로 반드시 의존성 배열에 추가해야 한다. 그러나 `count` 가 변경되는 것은 Effect가 정리된 후 다시 설정하는 것을 야기하므로 `count` 는 계속 증가할 것이다. 이것은 이상적이지 않다.

이러한 현상을 방지하려면 `c => c + 1` state 변경함수를 `setCount`에 추가해라.

```jsx
  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(c => c + 1); // ✅ State 업데이터를 전달
    }, 1000);
    return () => clearInterval(intervalId);
  }, []); // ✅ 이제 count는 의존성이 아닙니다
```

`c => c + 1`을 `count + 1` 대신 전달하고 있으므로, Effect는 더 이상 `count` 에 의존하지 않는다. 이 수정으로 인해 `count`가 변경될 때마다 Effect가 정리 및 설정을 다시 실행할 필요가 없게 된다.

### 불필요한 객체 의존성 제거하기

Effect가 렌더링 중에 생성된 객체나 함수에 의존하는 경우, 너무 자주 실행될 수 있다.

예를 들어 이 Effect는 매 렌더링 후에 다시 연결된다. 이는 렌더링마다 `options` 객체가 다르기 때문이다.

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  const options = { // 🚩 이 객체는 재 렌더링 될 때마다 새로 생성됩니다
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() => {
    const connection = createConnection(options); // 객체가 Effect 안에서 사용됩니다
    connection.connect();
    return () => connection.disconnect();
  }, [options]); // 🚩 결과적으로, 의존성이 재 렌더링 때마다 다릅니다
  // ...
```

렌더링 중에 생성된 객체를 의존성으로 사용하는 것을 피해라. 대신 객체를 Efefct 내에서 생성해라.

```jsx
  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
```

이제 `options` 객체를 Effect 내에서 생성하면, Effect 자체는 `roomId` 문자열에만 의존한다.

### 불필요한 함수 의존성 제거하기

이 예시에서 Effect는 매 렌더링 후에 다시 연결된다. 이는 렌더링마다 `createOptions` 함수가 다르기 때문이다.

```jsx
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  function createOptions() { // 🚩 이 함수는 재 렌더링 될 때마다 새로 생성됩니다
    return {
      serverUrl: serverUrl,
      roomId: roomId
    };
  }

  useEffect(() => {
    const options = createOptions(); // 함수가 Effect 안에서 사용됩니다
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, [createOptions]); // 🚩 결과적으로, 의존성이 재 렌더링 때마다 다릅니다
  // ...
```

리렌더링마다 함수를 처음부터 생성하는 것 그 자체로는 문제가 되지 않고, 이를 최적화할 필요는 없다. 그러나 이것은 Effect의 의존성으로 사용하는 경우 Effect가 리렌더링 후마다 다시 실행되게 한다.

렌더링 중에 생성된 함수를 의존성으로 사용하는 것을 피해라. 대신 Effect 내에서 함수를 선언해라.

```jsx
  useEffect(() => {
    function createOptions() {
      return {
        serverUrl: serverUrl,
        roomId: roomId
      };
    }

    const options = createOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
```

### Effect에서 최신 props와 state 읽기

> **개발 중인 기술!**
이 섹션은 안정 버전의 리액트에 반영되지 않은 실험적 API에 대해 설명한다.
> 

기본적으로 Effect에서 반응형 값을 읽을 때는 해당 값을 의존성에 추가해야 한다. 이렇게 하면 Efeect가 해당 값의 모든 변경에 반응하게 된다. 대부분의 의존성에서 원하는 동작이다.

**그러나 때로는 Effect에서 최신 props와 state를 반응하지 않고 읽고 싶을 수 있다.** 예를 들어 페이지 방문마다 쇼핑 카트에 담긴 항목 수를 기록하고 싶다고 가정해 보겠다.

```jsx
function Page({ url, shoppingCart }) {
  useEffect(() => {
    logVisit(url, shoppingCart.length);
  }, [url, shoppingCart]); // ✅ 모든 의존성이 선언됨
  // ...
}
```

**`url` 변경마다 새로운 페이지 방문을 기록하고 싶지만 `shoppingCart` 만 변경되는 경우에는 기록하고 싶지 않다면 어떻게 해야 할까?**

`shoppingCart` 를 의존성에서 제외하면 반응형 규칙을 어기게 된다. Effect 내에서 호출되는 코드이지만 변경에 반응하지 않기를 원한다면 `useEffectEvent` Hook을 사용하여 `Effect Event` 를 선언하고 `shoppingCart` 를 읽는 코드를 그 안에 이동시킬 수 있다.

```jsx
function Page({ url, shoppingCart }) {
  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, shoppingCart.length)
  });

  useEffect(() => {
    onVisit(url);
  }, [url]); // ✅ 모든 의존성이 선언됨
  // ...
}
```

**Effect 이벤트는 반응적이지 않으며 Effect의 의존성에서 배제되어야 한다.**

Effect 이벤트에는 비 반응형 코드(Effect 이벤트 로직은 최신 props와 state를 읽을 수 있음)를 배치할 수 있다.

`onVisit` 내의 `shoppingCart` 를 읽음으로써 `shoppingCart` 의 변경으로 인한 Effect의 재실행을 방지한다.

### 서버와 클라이언트에서 다른 컨텐츠를 표시하기

앱이 서버 렌더링을 사용하는 경우 (직접 또는 프레임워크를 통해) 컴포넌트는 두 가지 다른 환경에서 렌더링된다.

서버에서는 초기 HTML을 생성하기 위해 렌더링되고, 클라이언트에서는 리액트가 이벤트 핸들러를 해당 HTML과 연결하기 위해 다시 렌더링 코드를 실행한다.

이것이 hydration이 작동하려면 초기 렌더링 출력이 서버와 클라이언트에서 동일해야 하는 이유이다.

드물게 클라이언트에서 다른 내용을 표시해야 할 수 있다. 예를 들어 앱이 `localStorage` 에서 일부 데이터를 읽는 경우, 이를 서버에서 구현할 수 없다.

다음은 이것을 구현하는 방법이다.

```jsx
function MyComponent() {
  const [didMount, setDidMount] = useState(false);

  useEffect(() => {
    setDidMount(true);
  }, []);

  if (didMount) {
    // ... 클라이언트 전용 JSX 반환 ...
  }  else {
    // ... 초기 JSX 반환 ...
  }
}
```

앱이 로딩 중인 동안 사용자는 초기 렌더링 출력을 볼 것이다. 그다음 로딩 및 hydration이 완료되면 Effect가 실행되어 `didMount` 를 `true` 로 설정하면서 다시 렌더링이 동작한다.

이로써 클라이언트 전용 렌더링 출력으로 전환된다. Effect는 서버에서 실행되지 않으므로 초기 서버 렌더링 중의 `didMount` 는 `false` 가 된다.

이 패턴은 적절히 사용해야 한다. 느린 연결 환경을 가진 사용자는 초기 렌더링 화면을 상당한 시간 동안 볼 것이므로 컴포넌트의 모양을 급변시키지 않는 것이 좋다.

많은 경우에는 CSS를 사용하여 조건부로 다양한 것들을 표시하는 방법으로 대처할 수 있다.

---

## 트러블 슈팅

### Effect가 컴포넌트 마운트 시 2번 동작한다.

개발 환경에서 Strict Mode가 활성화되면 설정과 정리를 한 번 더 실행한다.

이것은 Effect의 로직이 올바르게 구현되었는지 확인하는 스트레스 테스트이다. → 버그 찾는데 유용

### Effect가 매 리렌더링마다 실행된다.

1. 먼저 의존성 배열에 값을 추가했는지 확인해 봐라.
2. 명시했는데도 그러면 의존성이 렌더링마다 다르다는 의미
    1. 의존성들을 콘솔에 찍어 확인 → 마우스 오른쪽 클릭 → 전역 변수로 저장 후 브라우저 콘솔을 사용해 의존성이 동일한지 확인할 수 있다.
    2. [`Object.is](http://object.is/)(temp1[0], temp2[0]);`
    3. 렌더링마다 다른 의존성을 찾아냈다면 일반적으로 다음 중 하나의 방법으로 수정할 수 있다.
        1. [Effect에서 이전 state 기반으로 state 업데이트하기](https://www.notion.so/useEffect-24e8fd0fae93800598dde884619a2066?pvs=21)
        2. [불필요한 객체 의존성 제거하기](https://www.notion.so/useEffect-24e8fd0fae93800598dde884619a2066?pvs=21)
        3. [불필요한 함수 의존성 제거하기](https://www.notion.so/useEffect-24e8fd0fae93800598dde884619a2066?pvs=21)
        4. [Effect에서 최신 props와 state 읽기](https://www.notion.so/useEffect-24e8fd0fae93800598dde884619a2066?pvs=21)
    4. 최후의 수단으로, `useMemo` 나 `useCallback` (함수의 경우)을 이용할 수 있다.

### Effect가 무한 반복된다.

Effect가 무한 반복되려면 다음 두 가지 조건이 충족되어야 한다.

1. Effect에서 state를 업데이트함
2. 변경된 state가 리렌더링을 유발하며, 이에 따라 Effect의 종속성이 변경됨.

문제를 해결하기 전에 Effect가 외부 시스템에 연결되어 있는지 스스로 자문해 봐라. 

Effect에서 왜 state를 변경했는가? 변경된 state가 외부 시스템과 동기화됐나? 또는 Effect를 통해 애플리케이션의 데이터 흐름을 관리하려고 하는 것인가?

외부 시스템이 없다면 Effect를 제거해서 로직을 단순화할 수 있는지 고려해라.

만약 실제로 어떤 외부 시스템과 동기화 중이라면 Effect가 state를 언제 어떤 조건에서 업데이트해야 하는지에 대해 고려해라. 컴포넌트의 시각적 출력에 영향을 주는 state가 변했나? 렌더링에 사용되지 않는 데이터를 추적해야 한다면 리렌더링을 야기하지 않는 ref가 더 적합할 수 있다. Effect가 필요 이상으로 state를 업데이트하는지 확인해라.

마지막으로 Effect가 제대로 된 시점에 state를 업데이트했지만 여전히 무한 반복되는 경우, 해당 state의 업데이트가 Effect의 종속성의 변경을 야기했을 수도 있다.

### 컴포넌트가 마운트 해제되지 않았음에도 정리 함수가 실행된다.

정리 함수는 마운트 해제 시 뿐만 아니라 변경된 종속성으로 인한 모든 리렌더링 전에 실행된다.

또한 개발 환경에서는 리액트가 컴포넌트가 마운트된 직후에 한 번 더 설정과 정리를 실행한다.

설정 코드와 상응하는 정리 코드가 없다면 보통은 코드에 문제가 있을 가능성이 높다.

```jsx
useEffect(() => {
  // 🔴 피하세요: 상응하는 설정 로직이 없는 정리 로직
  return () => {
    doSomething();
  };
}, []);
```

정리 로직은 설정 로직과 대칭이어야 하며 설정이 수행한 것을 중지하거나 되돌릴 수 있어야 한다.

```jsx
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]);
```

### Effect가 시각적인 작업을 수행하며, 실행되기 전에 깜빡임이 보인다.

Effect가 `브라우저가 화면을 그리는 것` 을 차단해야 하는 경우 `useEffect` 를 `useLayoutEffect` 로 대체해라. → 이건 렌더 직전 DOM 조작용!!

**이것은 대부분의 Effect에는 필요하지 않다.** 브라우저 페인팅 이전에 Effect를 실행하는 것이 중요한 경우에만 필요하다. 예를 들어 사용자가 보기 전에 툴팁의 위치를 측정하고 지정해야 하는 경우가 있다.
